<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"waitingchange.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="仓库坏了，丢了一些内容">
<meta property="og:type" content="website">
<meta property="og:title" content="懒人的胡言乱语">
<meta property="og:url" content="https://waitingchange.github.io/page/3/index.html">
<meta property="og:site_name" content="懒人的胡言乱语">
<meta property="og:description" content="仓库坏了，丢了一些内容">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="change">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://waitingchange.github.io/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>懒人的胡言乱语</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">懒人的胡言乱语</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="change"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">change</p>
  <div class="site-description" itemprop="description">仓库坏了，丢了一些内容</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/waitingchange" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;waitingchange" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:waiting0313@gmail.com" title="E-Mail → mailto:waiting0313@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2020/09/17/CMake/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/17/CMake/" class="post-title-link" itemprop="url">CMake</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-17 20:35:08" itemprop="dateCreated datePublished" datetime="2020-09-17T20:35:08+08:00">2020-09-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-01 14:57:05" itemprop="dateModified" datetime="2021-03-01T14:57:05+08:00">2021-03-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="为什么要使用CMake"><a href="#为什么要使用CMake" class="headerlink" title="为什么要使用CMake"></a>为什么要使用CMake</h1><p>嗯，考虑到能看到这里的基本都会对CMake 有一定了解，所以先不讲这东西是啥，问题是为啥要用这东西。</p>
<p>我们这边有一些需求，目的是基础功能保持稳定性，又因为涉及到多个类型的客户端（IOS、Android、Windows、Mac），那么共用的内容C++使用就是一种必然，同时考虑到后期的可维护性，CMake 的使用就应该是一种必然。</p>
<p>因为是要做公共基础内容，最直接的思考是提供静态库给各方使用，这也就间接回答了CMake 的用途，用来把源码生成二进制文件。</p>
<p>按照正常的流程，先给一个开胃菜，提供一个Demo。</p>
<p>推荐一个软件 <em>CLine</em> </p>
<p><img src="/images/CMake/CLineDemo.png" alt="CLineDemo"></p>
<p>刚好能够提供C++ 静态库和动态库。</p>
<p>因为我需要优先做Android 的内容，所以我一步到位直接使用了AndroidStudio。</p>
<p><img src="/images/CMake/AndroidCmake.png" alt="AndroidCmake"></p>
<p>上面是简单的创建工程，咱们接着往下面。</p>
<p>以CLine 为例子</p>
<p><img src="/images/CMake/ClineCMake.png" alt="ClineCMake"></p>
<p>CMake 文本的写法就是 需要设置 CMake version  然后给出一个 project(<strong>name</strong>)  name 为生成静态库名字 ，设置C11 ,然后就是给这个project 添加需要编译的CPP文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── build</span><br><span class="line">├── library.cpp</span><br><span class="line">└── library.h</span><br></pre></td></tr></table></figure>

<p>文件结构大致是这样，需要有**source file ** 、 <strong>build</strong> 文件夹（我不太喜欢CLine 默认的 cmake-build-debug，自己更改了）、和必需品 <strong>CMakeLists.txt</strong></p>
<p>不依赖工具，可以在终端进入到当前文件夹下面的build 文件夹 然后执行 <strong>cmake ..</strong></p>
<p>执行<strong>cmake 命令</strong>之后，需要生成库文件需要在当前命令行再次执行 <strong>make</strong> ， 等命令执行完毕，库文件就会出现在build 文件夹。</p>
<p>依靠CLine 就相对容易，直接点击右上角的debug 标志即可。</p>
<p>如果一切运行正常，在build 文件夹下面就会出现需要的 CmakeDemo 这个名字的二进制文件，因为我们需要的是静态库，那么到现在为止这个静态库可以被拿来使用了。</p>
<h2 id="如何检验是否为自己需要的二进制静态库"><a href="#如何检验是否为自己需要的二进制静态库" class="headerlink" title="如何检验是否为自己需要的二进制静态库"></a>如何检验是否为自己需要的二进制静态库</h2><p>我们想要提供出去稳定可靠的二进制库，那么自测是必须不可少的一环。讲一下我这边比较常用的方式，我会去创建一个适合的console 工程，或者如果使用xcode ， 我会创建一个可视化的对应平台APP，把库文件暴露的接口交给新建demo 工程，按照正常使用的流程，载入编译出来的库文件。</p>
<p>那么开搞。</p>
<p>因为这里打算先提供一下简单的demo ， 只演示一下如何使用CMake ，创建静态库和使用静态库，这里简单替换原来的打印名言<strong>Hello,world!</strong> 更改为 **”Hello, from static lib !” **</p>
<p>在进入build 文件夹执行过最后的 <strong>make</strong> 命令后，能够拿到库文件 <strong>libCmakeDemo.a</strong></p>
<p>我们放入到consoleDemo 工程中 然后文件结构是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── cmake-build-debug</span><br><span class="line">├── libCmakeDemo.a</span><br><span class="line">├── library.h</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure>

<p>更改CMakeLists.txt  内容如下</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置cmake version</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="comment">#设置变量名字</span></span><br><span class="line"><span class="keyword">set</span>(APP_NAME ConsoleDemo)</span><br><span class="line"><span class="comment"># 国际惯例 project name</span></span><br><span class="line"><span class="keyword">project</span>(<span class="variable">$&#123;APP_NAME&#125;</span>)</span><br><span class="line"><span class="comment">#C11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 这里需要链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libCmakeDemo.a)</span><br><span class="line"><span class="comment">#正常编译需要的 添加source 文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME&#125;</span> main.cpp library.h)</span><br></pre></td></tr></table></figure>

<p>我这边比较懒，就直接搬运了静态库中使用的头文件，因为属于函数定义，并且没有特殊要求，这里就直接可以拿来使用。</p>
<p>看下<strong>main</strong>函数中的修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就很简单了，直接引入头文件，然后在合适的地方进行执行。</p>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, from static lib !</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<p>如预期</p>
<p>先写到这里，下次可以讲一下全平台的一些东西，比如一些难点，如果从C++ 通过nodejs 异步回调给JavaScript（可不是正常设置进去一个回调然后等执行后就从C++那边执行到JavaScript ，这样就没有技术含量）使用libuv 可以多次从C++ 回调给JavaScript，下次讲讲如何实现。</p>
<p>惯例，使用的demo 地址  <a target="_blank" rel="noopener" href="https://github.com/waitingchange/cmakeDemo">Demo 地址</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2020/08/12/%E4%BD%BF%E7%94%A8vscode-%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95Node%20&C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/12/%E4%BD%BF%E7%94%A8vscode-%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95Node%20&C++/" class="post-title-link" itemprop="url">使用vscode 进行调试Node + C++ </a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-12 14:51:47" itemprop="dateCreated datePublished" datetime="2020-08-12T14:51:47+08:00">2020-08-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-01 14:42:41" itemprop="dateModified" datetime="2021-03-01T14:42:41+08:00">2021-03-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Nodejs/" itemprop="url" rel="index"><span itemprop="name">Nodejs</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="如何使用vscode-调试-nodejs-C"><a href="#如何使用vscode-调试-nodejs-C" class="headerlink" title="如何使用vscode 调试 nodejs + C++"></a>如何使用vscode 调试 nodejs + C++</h1><h3 id="先讲遇到的问题"><a href="#先讲遇到的问题" class="headerlink" title="先讲遇到的问题"></a>先讲遇到的问题</h3><p>Electron 部分发新版本，windows包，在一些设备上出现了崩溃，没有堆栈，没有可用信息，怀疑的点有一大堆。</p>
<p>以上是问题，解决思路是从git提交记录进行比对找出一些最怀疑的点进行日志跟踪，尝试找出崩溃发生前最后日志出现位置，推测上下文。</p>
<p>如何定位问题先不细讲，最后大致定位在native log日志部分，比如表现，在一些机器上关掉调用就可以正常，打开调用就会崩溃。</p>
<p>确定了崩溃发生的位置，因为在不同的机器上才会有不同的表现，所以崩溃发生的原因还是不太详细，而且初始化调用的顺序是js端先调用node文件c++暴露的接口，传递需要初始化的完整路径，node 文件将加工后的路径交给log日志系统进行业务的初始化。因为出现问题，所以整个环节都是可以怀疑的地方。</p>
<h3 id="如何缩小怀疑范围"><a href="#如何缩小怀疑范围" class="headerlink" title="如何缩小怀疑范围"></a>如何缩小怀疑范围</h3><p>比如从语言层面来讲，C++ 内部的相互调用机制这个基本可以排除怀疑，所以基本大概率怀疑的点应该是语言之间的交互部分，nodejs 提供的C++ Addon 部分就是怀疑对象的重点。</p>
<p>从结构来分，设计方案来讲，C++核心业务方是独立的模块儿，内部的逻辑和调用规则非常清晰，大概率问题不大。从语言交互部分来讲，如果按照规则使用问题也应该很少，对于整块儿业务来讲，这里出问题了，需要去排查，逐个排除。</p>
<p>发现规律应该能够减少更多的怀疑部分，比如这次遇到问题的时候发现在开发的机器上面没有任何问题，在用户的机器上面就能必现。不同的点就是用户的home 文件夹是使用中文的，开发和测试侧使用的是英文，开发侧有足够的依赖库可以正常使用，用户侧不确定是否全部包含。</p>
<p>目标锁定为中文是因为日志系统测试阶段没有考虑过中文路径，在开发时候会发现日志系统在windows 有额外处理部分，比如正反斜杠。</p>
<h3 id="验证猜测"><a href="#验证猜测" class="headerlink" title="验证猜测"></a>验证猜测</h3><p>C++ 核心功能部分被编译为了静态库，先编译debug 静态库，然后新建console 工程 载入和使用，打断点就能确认是否好使。确认传入的中文路径在日志初始化状态没有任何问题。这块儿基本排除了因为C++  的可能性。所以下一步测试从JavaScript 层传入中文路径，看Node 文件在接收参数之后传递给C++ 的值到底会是什么。带来一个新的问题，如何调试，如何断点。单一的打log并不能很直接的跟踪定位到问题所在，个人经验，跟踪log来解决手头问题令人抓狂又很低效。</p>
<h3 id="调试需要用的工具"><a href="#调试需要用的工具" class="headerlink" title="调试需要用的工具"></a>调试需要用的工具</h3><p>我们拿到关键字去搜索发现，可以debug C++ ，vscode 有插件儿  <a target="_blank" rel="noopener" href="https://github.com/vadimcn/vscode-lldb">CodeLLDB</a> ,因为需要调试C++ ，所以 <a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode-cpptools">C++ 调试插件</a>  不可少，需要调试node ，nodejs 系统安装也需要必备。</p>
<ul>
<li><p>Debugging on Linux (x64 or ARM), macOS and Windows*,</p>
</li>
<li><p>Conditional breakpoints, function breakpoints, data breakpoints, logpoints,</p>
</li>
<li><p>Launch debuggee in integrated or external terminal,</p>
</li>
</ul>
<p>上面是<strong>CodeLLDB</strong> 的介绍，可以在不同的平台方面提供断点等debug 功能。</p>
<p> **C/C++ **插件儿不多解释，需要断点C或者C++ 不是。</p>
<p>至于 <strong>Nodejs</strong> ，今天需要讲的重点，断点需要调试的就是 Nodejs addon，从JavaScript 启动可以断点js ，也可以断点到执行到的C++ 部分。</p>
<h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>先讲怎么做，然后再说为什么。</p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="/vidoes/调试nodejs c++.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>



<h3 id="讲一下为什么"><a href="#讲一下为什么" class="headerlink" title="讲一下为什么"></a>讲一下为什么</h3><p>需求是需要跨平台 debug nodejs 和c++ 部分，编辑器是vscode。从vscode 的插件儿开始入手。C++ 和 Nodejs 属于必备，关心的重点就是CodeLLDB。</p>
<p>如何使用CodeLLDB，比如他们快速开始。</p>
<p><img src="/images/codelldb/CodeLLDB_quick_start.png" alt="&quot;CodeLLDB_quick_start&quot;"></p>
<p><strong>name</strong> Launch configuration name. 明显是指的标识，type 应该是告诉vscode 需要执行哪一类调试。</p>
<p><strong>request</strong>： The <code>request</code> property of the configuration chooses how it will be done。 可以暂时理解为目的。</p>
<p><strong>program</strong>:Path to the debuggee executable.  需要launch执行的路径。</p>
<p><strong>args</strong>: Command line parameters. If this is a string, it will be split using shell-like syntax.  执行时候需要传递的参数</p>
<p><strong>cwd</strong>: Current Working directory.   当前工作路径</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;lldb:node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;--inspect-brk&quot;</span>, <span class="string">&quot;--expose-gc&quot;</span>,<span class="string">&quot;main.js&quot;</span>], <span class="comment">// --inspect-brk  参看nodejs  , node --expose-gc  main.js 可以手动代码执行gc()</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这边在使用的lldb launch 配置。</p>
<p><img src="/images/codelldb/nodeinspect.png" alt="&quot;nodeinspect&quot;"></p>
<p>在使用launch的时候我们使用了inspect 的参数，于是当我们真正调试的时候，需要监听的端口号为9229。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;attach&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;node:attach&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="number">9229</span>,</span><br><span class="line">    <span class="attr">&quot;skipFiles&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;node_internals&gt;/**&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面的基本介绍，这里的一些参数似乎显得就是很自然的一些内容。<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging">skipFiles vscode nodejs debug介绍</a>  </p>
<p>因为需要经历两个步骤，先launch 需要debug 的内容，然后attach 住正在执行的内容，才能够达到debug 的目的。</p>
<p><strong>compounds</strong>: vscode 提供了这个字段，很明显是为了大家执行方便，让逻辑按照执行顺序去执行。</p>
<p><strong>preLaunchTask</strong>字段，从字面意思就能了解是在做一些列操作之前可以先执行某种动作。</p>
<p><img src="/images/codelldb/compounds.png" alt="compounds"></p>
<p>演示的视频是在Mac 下面做的，在windows下面配置部分会略微不同，但是流程是一样的，需要先launch ，然后在attach node 文件，进而在需要的地方进行断点。</p>
<p>附加： ：<a href="git@github.com:waitingchange/vscode_debug_nodejs_cpp.git">视频中用于测试的Demo 工程 Git 地址</a>      <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;</a>:waitingchange/vscode_debug_nodejs_cpp.git</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2020/03/03/%E8%87%AA%E5%88%B6%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/03/%E8%87%AA%E5%88%B6%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">自制爬虫工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-03 19:00:29" itemprop="dateCreated datePublished" datetime="2020-03-03T19:00:29+08:00">2020-03-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-13 13:35:27" itemprop="dateModified" datetime="2020-03-13T13:35:27+08:00">2020-03-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%87%92%E4%BA%BA%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">懒人工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2019/07/29/%E7%8E%A9%E5%84%BF%E8%BD%ACCocos-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/29/%E7%8E%A9%E5%84%BF%E8%BD%ACCocos-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">玩儿转Cocos 文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-29 17:09:15" itemprop="dateCreated datePublished" datetime="2019-07-29T17:09:15+08:00">2019-07-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-09-21 15:18:22" itemprop="dateModified" datetime="2019-09-21T15:18:22+08:00">2019-09-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Cocos/" itemprop="url" rel="index"><span itemprop="name">Cocos</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>#如何玩转 Cocos 文件系统</p>
<h2 id="1-资源是如何被找到的"><a href="#1-资源是如何被找到的" class="headerlink" title="1.资源是如何被找到的"></a>1.资源是如何被找到的</h2><p>&nbsp;&nbsp;     没做开发以前一直在想一个问题，文件如何被计算机找到并且执行？ 当知道计算机在执行 <em>0101</em> 的二进制文件时候就又在想，我们的图片、声音等文件应该是变成了机器代码之后才能被读出来和执行。于是抱着这种想法开始了codeing。偶然有一次发现，Android 的 apk 包竟然可以用zip 解压工具解开，里面竟然找到了一些未经过压缩的图片和其他资源。在好奇心的驱使下就想要搞明白计算机是如何做到的。在玩儿 <strong>Cocos</strong> 的过程中，接触到了<strong>FileUtils</strong>这个类文件。顺着源码部分我们去看，发现在经过引擎一系列优化以后，查找文件代码最终调用了系统方法，根据文件的名字，在APP的指定路径（包里面或者可读写路径下）返回资源文件的全路径。</p>
<p>&nbsp;&nbsp;    似乎经过上面一说，整片文章就可以结束了。以Cocos lua 为例子 我们尝试列一下流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先说一下 luafile  部分</span></span><br><span class="line"><span class="comment">// cocos lua 部分入口是在c++ 初始化 LuaEngine 以后执行lua 代码</span></span><br><span class="line">  <span class="keyword">if</span> (engine-&gt;executeScriptFile(<span class="string">&quot;src/main.lua&quot;</span>)) </span><br><span class="line"><span class="comment">// LuaEngine 之后做了如下操作</span></span><br><span class="line">  LuaStack  去执行了  executeScriptFile(filename);</span><br><span class="line"><span class="comment">// 判断结尾，确认是 lua 还是 luac</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = utils-&gt;fullPathForFilename(buf);</span><br><span class="line">  Data data = utils-&gt;getDataFromFile(fullPath);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// data 存在 执行</span></span><br><span class="line">  <span class="keyword">if</span> (luaLoadBuffer(_state, (<span class="keyword">const</span> <span class="keyword">char</span>*)data.getBytes(), (<span class="keyword">int</span>)data.getSize(), 			fullPath.c_str()) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      rn = executeFunction(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;    脚本文件在执行之前，需要通过引擎代码 <em>FileUtils</em> 进行定位文件具体位置，然后获取文件buffer 内容和长度以后进行执行。</p>
<p>&nbsp;&nbsp;    我们于是可能会好奇图片文件是如何被载入和执行的，上面的流程是否满足图片资源的需求 ？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Talk is cheap , show me the code</span></span><br><span class="line">  Sprite::create(fileName)</span><br><span class="line"><span class="comment">// 跟踪fileName</span></span><br><span class="line">  <span class="keyword">if</span> (sprite &amp;&amp; sprite-&gt;initWithFile(filename))</span><br><span class="line"><span class="comment">//Cocos 使用了 Texure2d</span></span><br><span class="line">  Texture2D *texture = Director::getInstance()-&gt;getTextureCache()-&gt;addImage(filename);</span><br><span class="line"><span class="comment">//继续关心fileName 是如何最后变成 Texture2D 对象的</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fullpath = FileUtils::getInstance()-&gt;fullPathForFilename(path);</span><br><span class="line">  <span class="keyword">bool</span> bRet = image-&gt;initWithImageFile(fullpath);</span><br><span class="line"><span class="comment">// 于是继续向下查找</span></span><br><span class="line">  _filePath = FileUtils::getInstance()-&gt;fullPathForFilename(path);</span><br><span class="line">  Data data = FileUtils::getInstance()-&gt;getDataFromFile(_filePath);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;  似乎图片资源从file到 机器可识别的Data 也需要关键的两步，findPath ,getData </p>
<p>&nbsp;&nbsp;  我们可以继续去验证其他后缀结尾的文件，大多数都在执行同样的流程。为甚叫做大多数呢 ？ 当你实验到音频文件的时候，例如 mp3 ，最后执行的貌似并不是当前的流程。读代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 感兴趣的点在哪里</span></span><br><span class="line">  AudioEngine::play2d</span><br><span class="line"><span class="comment">//屡一下源码部分  容错处理</span></span><br><span class="line">  <span class="keyword">if</span> ( !FileUtils::getInstance()-&gt;isFileExist(filePath))&#123;</span><br><span class="line">  		<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = _audioEngineImpl-&gt;play2d(filePath, loop, volume);</span><br><span class="line"><span class="comment">//在ios一侧 使用了  SimpleAudioEngine</span></span><br><span class="line">  -(<span class="keyword">void</span>) playBackgroundMusic:(NSString*) filePath</span><br><span class="line">  &#123;</span><br><span class="line">   [am playBackgroundMusic:filePath loop:TRUE];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 看到OC 代码的时候 就会发现，对于 SimpleAudioEngine 库来讲，需要的仅仅是文件的绝对地址 ，这个音频库会找到		文件然后进行播放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;    我们希望引擎中代码部分和整体的设计流程保持一致，大多数文件是保持了先经过 FileUtils 获取到文件在设备存放的位置，然后读取file Buffer 之后再次加工处理。</p>
<p>&nbsp;&nbsp;    设计结构的时候，我们经常会对内容进行归类，找出共同点，然后进行粗略处理，最后不同之处做区分。现实情况中我们总会发现Cocos原生打包内容资源部分容易被盗，脚本代码也很容易被还原，安全方面几乎无法保证，虽然逻辑部分能正常work 。</p>
<p>&nbsp;&nbsp;    代码的主要逻辑在于如何获取文本 <em>Buffer</em> 和 <em>Length</em> 面对上面的常见问题， 所以具体原始文件是什么形式我们不是特别关心，只是要给到 <em>fileName</em> 我们正确的返回 <em>Buffer</em> 和 <em>Length</em> 就可以了。 加入文件名字是被算法加密了呢？假如文本内容是被高效率解析加密函数加密了呢？很多事情貌似可以直接上手做。设想和做是两回事儿。</p>
<p>&nbsp;&nbsp;    万一文件名字和内容都被一个加密算法加密了呢 ？比如ZIP</p>
<p>&nbsp;&nbsp;    为什么是zip ？ 在读FileUtils 类的时候有一个函数很吸引人 <em>FileUtils::getFileDataFromZip</em></p>
<p>&nbsp;&nbsp;    选择ZIP会有一些优势，最简单常见的是可以给资源进行压缩和加密，如果是需要进行热更操作的资源呢？连续性大文件下载的优势就有了，而且具有压缩的特点，资源或者代码的热更时间会大大减少。有没有了解过zip文件的结构？考虑到每一个文件，你会关心哪些数据？简单理解ZIP文件为一大片连续的数据段？</p>
<p>&nbsp;&nbsp;    我们在读Cocos 提供的unzip文件的时候会发现几个比较有意思的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unzOpen</span><br><span class="line">unzGoToFirstFile64</span><br><span class="line">unzGetFilePos</span><br><span class="line">unzGoToNextFile64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unzGoToFilePos</span><br><span class="line">unzOpenCurrentFilePassword</span><br><span class="line">unzReadCurrentFile</span><br></pre></td></tr></table></figure>

<p>如果理解ZIP 文件为长串儿连续压缩文件的话也并不是不可以，只不过每一个文件头部都有包含一些信息：1.文件名字，无压缩文件大小，起始文件地址等。依靠这些文件已经可以把压缩文件解压缩读出。</p>
<p>Demo 暂时不列出，思路可以提供。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2019/04/11/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Android-SO-%E8%8E%B7%E5%8F%96-xxtea-%E5%AF%86%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/11/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Android-SO-%E8%8E%B7%E5%8F%96-xxtea-%E5%AF%86%E7%A0%81/" class="post-title-link" itemprop="url">动态调试Android SO 获取 xxtea 密码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-11 16:50:51" itemprop="dateCreated datePublished" datetime="2019-04-11T16:50:51+08:00">2019-04-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-04-17 15:52:31" itemprop="dateModified" datetime="2019-04-17T15:52:31+08:00">2019-04-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android-%E5%8F%8D%E7%BC%96%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">Android 反编译</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一步一步获取Cocos2dx-xxtea-密码"><a href="#一步一步获取Cocos2dx-xxtea-密码" class="headerlink" title="一步一步获取Cocos2dx xxtea 密码"></a>一步一步获取Cocos2dx xxtea 密码</h1><h2 id="1-准备工具"><a href="#1-准备工具" class="headerlink" title="1.准备工具"></a>1.准备工具</h2><ol>
<li><p>Android 手机一部，最好是 32位处理器，必须能root </p>
</li>
<li><p>IDA Pro </p>
</li>
<li><p>cocos apk 确认使用xxtea （cocos new HelloLua -l lua 然后生成apk）</p>
</li>
</ol>
<h2 id="2-电脑环境-win-or-Mac"><a href="#2-电脑环境-win-or-Mac" class="headerlink" title="2.电脑环境 win or Mac"></a>2.电脑环境 win or Mac</h2><p>​    电脑需要能够使用 adb 命令 ，建议安装 apktool （防止apk 没有配置 <em>android:debuggable=”true”<em>，如果apk包不能直接调试请自行查找如何重新打包apk ） ，Android Studio 需要安装 （主要为了分析 manifest 文件 Application 中是否配置</em>android:debuggable=”true”</em>  另外需要使用 sdk 文件夹 tool 下面 monitor  ，win 下面可以使用 ADT Bundle 中 ddms ） 因为个人使用习惯问题，这里讲述如何在mac 系统下面操作。</p>
<h2 id="3-具体操作步骤"><a href="#3-具体操作步骤" class="headerlink" title="3.具体操作步骤"></a>3.具体操作步骤</h2><ol>
<li><p>Android 手机具有root 权限 而且已经安装被调试的apk包，在pc端 打开终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell </span><br><span class="line">su</span><br><span class="line">cd &#x2F;data&#x2F;app      #查看包名文件夹是 为debug 启动 应用做准备</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<p>在真正启动调试以前需要把 ida pro 提供的 android_server 文件放在 Android手机的 <em>/data/local/tmp</em> 文件夹下，操作方式可以使用 <em>adb push</em> 或者拷贝文件到手机SD 卡中，然后通过命令形式挪动到 <em>/data/local/tmp</em> ，<strong>重要的是android_server 文件需要给与可执行权限， 所以Android 手机需要有Root 权限</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell </span><br><span class="line">su</span><br><span class="line">cd &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line">chmod 777 android_server</span><br><span class="line">.&#x2F;android_server</span><br></pre></td></tr></table></figure>
<p><img src="/images/android_tem_1.jpg" alt="&quot;执行终端截图&quot;"><br><img src="/images/android_tem_2.jpg" alt="&quot;执行android_server&quot;"></p>
<p>从截图可以看到已经启动了android_server 端口是 23946 ， 需要使用  adb命令将端口映射至电脑  23946 <strong>为啥是这个端口? Ida Pro 在Attach Android时候默认监听端口是这个</strong><br><img src="/images/android_tem_3.jpg" alt="&quot;adb 转发&quot;"></p>
<p>准备工作应该差不多了，剩下的就是如何调戏Apk </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">am start -D -n org.cocos2dx.HelloLua&#x2F;org.cocos2dx.lua.AppActivity   #debug 形式启动apk</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_tem_4.png" alt="&quot;命令启动apk&quot;"></p>
<p>am start 启动Android Activity  <strong>-D: 允许调试功能 ， -n <COMPONENT>: 指定组件名，格式为{包名}/.{主Activity名}</COMPONENT></strong></p>
<p><img src="/images/android_tem_5.png" alt="&quot;App启动后截图&quot;"></p>
</li>
<li><p>启动 DDMS (win)  or Monitor (mac)</p>
<p>也许会在想，为啥是DDMS ?  自己粗略的理解，为了查看App debug 信息（不一定正确，如果有确定的答案麻烦通知我）。 在Devices 里面能够看到等待调试的app信息，包名，端口等  但是发现debug 的标识还是红色，意思是暂时还不能调试，所以监视器已经被启动，剩下操作如何使用IDA 连接手机然后调试<br><img src="/images/android_tem_6.png" alt="&quot;DDMS能看到的内容&quot;"></p>
</li>
<li><p>IDA 部分操作<br>准备工作和启动APP 已经结束了，剩下的是需要借助 IDA 这货来获取我们想要的内容。好戏才刚刚开始~<br>我在使用 Mac 版本 IDA Pro 7.0 ，具体下载地址暂时不提供，毕竟业余水平的我也买不起。</p>
<p>IDA Pro 一直存在 两个可执行文件， 32 位和 64 位之分。区别在于 32 位可以使用 F5 把二进制中函数部分难以理解的汇编转化为稍微容易可读的 C 语言。 推荐暂时使用 32 位，所以 也推荐使用 32 位处理器的 Android 手机（2019 年的今天已经很难找到，我的测试机器是A0001, 骁龙 801 处理器 64位 ,尴尬的笑脸），细心的同学们会发现在 IDA 提供的 android_server 文件在 dbgsrv 文件夹下面包含两个， 另外一个文件是 android_server64 （使用这个文件的时候请打开 IDA Pro 64）。啰嗦到此为止，我们已经打开了 IDA Pro ,需要操作的是 Attach  Android 设备。</p>
<p><img src="/images/android_tem_7.png" alt="&quot;IDA Attach&quot;"></p>
<p>点击 Remote ARMLinux / Android Debugger</p>
<p><img src="/images/android_tem_8.png" alt="&quot;Set Debugger&quot;"></p>
<p>然后点击 Debug options</p>
<p><img src="/images/android_tem_9.png" alt="&quot;Debug options&quot;"></p>
<p>请根据我的设置进行配置，如果你想要别的功能，那么请自行设置，然后点击确定。</p>
<p>回到Debugg application setup 界面， Hostname 请写localhost 或者 127.0.0.1 端口号默认 23946 然后点击OK</p>
<p>在新弹出的页面请点击seach 然后输入你需要调戏的包名（可以输入部分关键字进行查找）<br><img src="/images/android_tem_10.png" alt="&quot;Debug options&quot;"></p>
<p>然后就是点击OK<br><img src="/images/android_tem_11.png" alt="&quot;Debug&quot;"></p>
<p>到现在这个地方才是真正开始准备获取cocos xxtea 密码的位置。 正如前面讲到的，Monitor 中显示 APP Debug 的标识是红色的，meaning 不能调试。 解决这个问题需要一行命令，终端输入如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;127.0.0.1,port&#x3D;8700 #如果 8700 不好使 那就试一下 8600  为什么请问Google</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_tem_12.png" alt="&quot;Debug&quot;"></p>
<p>当执行完命令时候 ，Monitor 中 debug的图标变成了绿色，所以，下一步就是开始反编译</p>
<p>在准备下一步的时候我们需要考虑，目的到底是什么？ 需要看哪里 ？ 已知：IDA Pro 可以在二进制部分函数中进行打断点单步调试。在 Cocos 中，C++ 中的代码会最终编译到 <strong>libcocos2dlua.so</strong>， 所以需要先定位到 so包，然后再次定位到相应函数，最基本的执行逻辑。IDA Pro 可以进行断点，所以需要再函数执行以前进行打上断点，等执行到断点时候查看内容。问题来了，如何做 ？ 在什么地方打断点？如何判断so包是否被载入？如何判定打断点的函数就是你需要的函数 ？ 如何查看自己想要的值 ？一些列的问号等着解决</p>
</li>
<li><p>知识补充 如何查找需要debug 的函数</p>
<p> 目的：拿到 xxtea 解密密码。 目的很明确，所以先找到Cocos 源码部分，找到xxtea.h </p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">xxtea_encrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data, xxtea_long data_len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, xxtea_long key_len, xxtea_long *ret_length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">xxtea_decrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data, xxtea_long data_len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, xxtea_long key_len, xxtea_long *ret_length)</span></span>;</span><br></pre></td></tr></table></figure>

<p> xxtea_decrypt 多么刺眼，如果，我指的是如果，Cocos 的包开发者没有这块的安全意识，基本上这块的代码应该不会改动。所以，IDA 静态反编译<strong>libcocos2dlua.so</strong> ,在能够列出的函数列表中我们查找 xxtea 字段，万一能够查到我们想要的内容呢 ？</p>
<p> 我另外开启了一个 IDA  用来静态反编译 ** libcocos2dlua.so** ， 在function 列表中查找 <em>xxtea</em> 如下截图<br> ​    <img src="/images/android_tem_13.png" alt="&quot;Debug&quot;"></p>
<p> 有的时候结果就是这么的让人欣喜。能找到这个函数，那么剩下的问题是如何在合适的时间打上断点，然后让APP断在我们想要的位置 ？在这个之前，得先找到什么时候SO 包被载入。所以往下面看。<br>​</p>
</li>
<li><p>继续跟踪调试</p>
<p> 回到我们使用IDA Pro 连接好的准备调试界面，我们在IDA 的debug 选项中选择了加载so包的时候断住，但是在我的测试中发现貌似我这个在载入<strong>libcocos2dlua.so</strong><br> 并没有断住。同时也发现暂时并没有载入 <strong>libcocos2dlua.so</strong> 。所以开始想办法，如何去断点调试。IDA Pro 提供了 <em>F8 单步调试</em> ， <em>F9 继续执行</em>。在右侧的 Modules 中 <em>ctrl + f 查找 cocos</em> 发现没有内容。使用比较粗糙的方法，<em>F8 一下一下的嗯，遇到弹框就点击继续一直到libcocos2dlua.so载入成功</em>  在SO 载入成功以后，Modules 里面也出现了我们想要的 SO 包。赞！</p>
<p> <img src="/images/android_tem_14.jpg" alt="&quot;Debug&quot;"></p>
<p> 双击 Modules 中 libcocos2dx.so ,然后查找 <em>xxtea</em><br> ​      <img src="/images/android_tem_15.jpg" alt="&quot;Debug&quot;"></p>
<p> 在这里打完断点以后可以使用 <strong>F9 让App 执行到断点位置</strong><br> 我们在断点位置摁一下F5 会怎样 ？(如果使用了 64 位的IDA ，那么貌似暂时不支持)<br>  <img src="/images/android_tem_16.jpg" alt="&quot;Debug&quot;"></p>
<p> 我们看到汇编语言版本的代码被ida 转化为了 略微熟悉的 C 语言， 根据我们xxtea_decrypt 源码我们发现，第三个只才是我们需要的 key 。 胜利在望,我们移动鼠标放在 a3 上面，发现 r2 寄存器才是我们要查找的内容<br>  <img src="/images/android_tem_17.png" alt="&quot;Debug&quot;"></p>
<p> 双击一下 a3 会如何 ？<br>   <img src="/images/android_tem_18.jpg" alt="&quot;Debug&quot;"></p>
<p> 或者在下面的 Hex View-1 中点击右键 Synchorize with  中选择 R2<br>  <img src="/images/android_tem_19.jpg" alt="&quot;Debug&quot;"></p>
</li>
</ol>
<h2 id="4-密码部分已经给你了，其余的就自己看着办吧"><a href="#4-密码部分已经给你了，其余的就自己看着办吧" class="headerlink" title="4.密码部分已经给你了，其余的就自己看着办吧"></a>4.密码部分已经给你了，其余的就自己看着办吧</h2><p>​    ps. 转载前请先联系我  <a href="mailto:&#119;&#x61;&#105;&#x74;&#x69;&#110;&#103;&#48;&#x33;&#49;&#x33;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;">&#119;&#x61;&#105;&#x74;&#x69;&#110;&#103;&#48;&#x33;&#49;&#x33;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;</a><br>    提供测试 apk 下载 <a href="/download/HelloLua-debug.apk" title="测试APK下载">点击下载</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2019/01/26/%E6%80%8E%E6%A0%B7%E8%8E%B7%E5%8F%96fir-im%E4%B8%AD%E7%9A%84IPA%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/26/%E6%80%8E%E6%A0%B7%E8%8E%B7%E5%8F%96fir-im%E4%B8%AD%E7%9A%84IPA%E5%8C%85/" class="post-title-link" itemprop="url">怎样获取fir.im中的IPA包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-26 11:01:44" itemprop="dateCreated datePublished" datetime="2019-01-26T11:01:44+08:00">2019-01-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-02-14 19:20:49" itemprop="dateModified" datetime="2019-02-14T19:20:49+08:00">2019-02-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="述求如题，怎样获取托管网站中分发的iOS安装包-？"><a href="#述求如题，怎样获取托管网站中分发的iOS安装包-？" class="headerlink" title="述求如题，怎样获取托管网站中分发的iOS安装包 ？"></a>述求如题，怎样获取托管网站中分发的iOS安装包 ？</h1><p>&emsp;&emsp;百度搜索，关键字 fir.im iOS安装包 ，第一篇，使用抓包。鉴于我不太会使用，所以暂时先放弃，其余的，跟关键字似乎无关。只有抓包才好使 ？保持怀疑。。。</p>
<p>&emsp;&emsp;先把如何获取到放在一边，尝试了解一下需要下载的是什么。企业签名包如何制作，继续百度关键字，出现的结果都是多少多少钱，吐槽弃用。作为一个技术，我自己主要的搜索是Google，从这里我们可以找到相对满意的答案。比如我查到的结果 <a target="_blank" rel="noopener" href="https://www.goodbarber.com/blog/distribute-your-ios-app-out-of-the-store-with-the-apple-developer-enterprise-program-a871/">企业签名如何制作</a>。企业签名包在最后会生成一个plist文件，提供链接给ios设备Safari ，然后就可以自动安装。</p>
<p>&emsp;&emsp;回归主题，汇总知道，需要下载plist ， 需要使用Safari。所以我们需要去fir.im 中去猜想他们是如何操作的的。</p>
<p>&emsp;&emsp;1.首先我们需要一个fir.im 中对于APP 的一个下载地址，比如：<a target="_blank" rel="noopener" href="https://fir.im/2cra">https://fir.im/2cra</a> （网上资源，如果侵权请联系删除）</p>
<p>&emsp;&emsp;2.iPad 或者 iPhone中使用 Safari 打开链接。</p>
<p>&emsp;&emsp;3.手机中开启 Safari中高级设置 –&gt; Web Inspector </p>
<p>&emsp;&emsp;4.手机连接电脑，打开Safari ，Developer –&gt; ipad —&gt; fir.im/2cra  如图</p>
<p><img src="/images/safari_inspect.png" alt="&quot;inspect 截图&quot;"> 查看网页源码，根据文件名字，最感兴趣的应该是download.js 。 所以我们查看文本内容。根据我们获取的信息知道plist下载链接前面需要有 <em>itms-services://?action=download-manifest&amp;url=</em> 所以，我们查找之后的截图如下</p>
<p><img src="/images/safari_plist_url_code.png" alt="&quot;plist链接如图&quot;"> 匹配到的函数是 plistUrl  和  iosSchema</p>
<p>Safari 提供断点跟踪，所以，开始搞事情！！！</p>
<p><img src="/images/safari_plist_url_value.png" alt="&quot;plist真实链接&quot;"> 貌似拿到了下载链接，如何验证呢 ？</p>
<p>&emsp;&emsp;chrome 里面装上一个插件，使用iPad 访问链接，比如 <em>User-Agent Switcher for Chrome</em> 在头部加上http://   扔到浏览器访问，直接出来下载的plist   文件名字叫做 <strong>install</strong>  我们使用文本工具查看文件内容<img src="/images/safari_plist_install_content.jpg" alt="&quot;install 文件&quot;"></p>
<p>&emsp;&emsp;<em><a target="_blank" rel="noopener" href="https://ali-fir-pro-binary.fir.im/fe5b21535e0c908bb95adc7560c8ab8db9a914fa?auth_key=1548583391-0-0-73f83a6c4d6151baba81747148ff0f8b">https://ali-fir-pro-binary.fir.im/fe5b21535e0c908bb95adc7560c8ab8db9a914fa?auth_key=1548583391-0-0-73f83a6c4d6151baba81747148ff0f8b</a></em> 链接地址就是ipa下载地址，丢到浏览器，完事儿。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2018/12/23/Cocos%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/12/23/Cocos%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Cocos文件管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-23 15:00:31" itemprop="dateCreated datePublished" datetime="2018-12-23T15:00:31+08:00">2018-12-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-01-13 12:48:31" itemprop="dateModified" datetime="2019-01-13T12:48:31+08:00">2019-01-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Cocos/" itemprop="url" rel="index"><span itemprop="name">Cocos</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Cocos-中脚本文件是如何被载入和执行"><a href="#Cocos-中脚本文件是如何被载入和执行" class="headerlink" title="Cocos 中脚本文件是如何被载入和执行"></a>Cocos 中脚本文件是如何被载入和执行</h1><p>&emsp;&emsp;Cocos 是可以执行 lua 和 js 的，lua 和 js 都可以认为是解释性语言，不涉及编译和链接步骤，那么文件是如何在Cocos中被载入到内存中并且被执行呢 ？</p>
<p>&emsp;&emsp;前提，我们知道不管是IOS 系统还是 Android 系统，Cocos 的执行流程都是需要把MainLoop 执行起来。如果这个流程不太清楚，请参看我上一个帖子   <strong>Cocos 代码执行流程</strong></p>
<p>&emsp;&emsp;以Cocos lua 为例，前面的代码部分已经解释了，在执行MainLoop 之前，AppDelegate::applicationDidFinishLaunching 函数中会先执行lua 虚拟机的初始化 和 设定 脚本执行的入口文件，我们继续跟踪代码执行，去发现Cocos 在文件操作方面是具有如何的特点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine-&gt;executeScriptFile(<span class="string">&quot;src/main.lua&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于main.lua 我们很熟悉，cocos-lua 中lua脚本执行入口文件。我们知道硬盘可以容纳很多的文件内容，但是这些文件内容在没有被计算机读取的时候就仅仅是存放而已，真正有效是在载入到内存以后被cpu处理的时候，话外题，先pass。我们继续回到main.lua ，同样，在入口的时候一定会先将文件载入到内存，那么文件的IO操作一定少不了。因为使用lua语言编写的，所以lua解释器需要介入和解释文本内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//猜想执行流程</span></span><br><span class="line"><span class="keyword">if</span>(isFileExistence)&#123;</span><br><span class="line">    <span class="comment">//执行文本IO 根据文本类型读取内容</span></span><br><span class="line">        FILE *fp = fopen(fullPath.c_str(), mode);</span><br><span class="line">        fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="comment">//获取长度</span></span><br><span class="line">        *size = ftell(fp);</span><br><span class="line">        fseek(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="comment">//获取文本内容 放入内存</span></span><br><span class="line">        buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(*size);</span><br><span class="line">        *size = fread(buffer,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>), *size,fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//判断如果文本是经过 xxtea 加密</span></span><br><span class="line">    <span class="comment">//拿到加密的buffer 进行解密 返回原始内容</span></span><br><span class="line">    <span class="comment">//拿到原始内容以后进行解释执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果这里没其他需求，最简单和直接的思路应该是这样的，所以我们转向看下Cocos 的代码部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> BYTECODE_FILE_EXT    = <span class="string">&quot;.luac&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> NOT_BYTECODE_FILE_EXT = <span class="string">&quot;.lua&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LuaStack::executeScriptFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">buf</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="comment">// remove .lua or .luac</span></span><br><span class="line">   	...</span><br><span class="line">    FileUtils *utils = FileUtils::getInstance();</span><br><span class="line">    <span class="comment">// 1. check .lua suffix 2. check .luac suffix</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tmpfilename = buf + NOT_BYTECODE_FILE_EXT;</span><br><span class="line">    <span class="keyword">if</span> (utils-&gt;isFileExist(tmpfilename))&#123;</span><br><span class="line">        buf = tmpfilename;  <span class="comment">// .lua file</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tmpfilename = buf + BYTECODE_FILE_EXT;</span><br><span class="line">        <span class="keyword">if</span> (utils-&gt;isFileExist(tmpfilename))&#123;</span><br><span class="line">            buf = tmpfilename;  <span class="comment">// .luac file</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取全路径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = utils-&gt;fullPathForFilename(buf);</span><br><span class="line">    Data data = utils-&gt;getDataFromFile(fullPath); <span class="comment">//获取buffer</span></span><br><span class="line">    <span class="keyword">int</span> rn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!data.isNull())&#123;</span><br><span class="line">        <span class="comment">//载入lua buffer</span></span><br><span class="line">        <span class="keyword">if</span> (luaLoadBuffer(_state, (<span class="keyword">const</span> <span class="keyword">char</span>*)data.getBytes(), (<span class="keyword">int</span>)data.getSize(), fullPath.c_str()) == <span class="number">0</span>)&#123;</span><br><span class="line">            rn = executeFunction(<span class="number">0</span>); <span class="comment">//执行栈顶 func</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;跟Cocos 这边进行对比发现基本逻辑实现好像差不多（所以我们也可以按照自己意愿封装自己的引擎了）。文本最终执行到了lua虚拟机然后进行函数执行。解释到这里似乎基本上已经完事儿了，是确定这样的吗？会有好奇心想要知道文本如何高效率精准被找到的吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取全路径   如何做到的 ？</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = utils-&gt;fullPathForFilename(buf);</span><br><span class="line">   Data data = utils-&gt;getDataFromFile(fullPath); <span class="comment">//获取buffer 有什么其他要注意的吗 ？</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在我们的FileUtils 中有对外暴露的  setSearchPaths 函数，直面翻译函数名字叫做设置文件搜索路径。在我们不知道内部如何实现的时候我们可以尝试使用自己的思路进行猜测别人的逻辑如何实现，如果最后发现很接近，这样是不是很开心？如果发现不太一样，我们是不是能学到一些别人优秀的设计思想 ？继续回归代码层面，我们先做设想。设置进来的是文件路径数组，那么数组有两个目的，第一临时存储，第二方便遍历。所以从方便遍历的角度来讲进行文件查找，我们推测。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isFileNameExistence)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; arry.length;i++)&#123;</span><br><span class="line">        <span class="comment">//1.取出每一个字符串中的内容 + 传递进入的文件名字</span></span><br><span class="line">        <span class="comment">//2.判断  isFileExist(tmpfilename) 存在的话就返回拼接后的字符串，</span></span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="comment">//在最后如果没找到就返回没找到标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们看下源码实现部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">FileUtils::fullPathForFilename</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;filename)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  <span class="comment">//空字符串监测</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAbsolutePath(filename))&#123;</span><br><span class="line">        <span class="keyword">return</span> filename; <span class="comment">//绝对路径直接返回 优化的点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Already Cached ?  加入了缓存机制  _fullPathCache</span></span><br><span class="line">    <span class="keyword">auto</span> cacheIter = _fullPathCache.find(filename);</span><br><span class="line">    <span class="keyword">if</span>(cacheIter != _fullPathCache.end())&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheIter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get the new file name. 缓存机制中使用了字典，所以字典两边都需要进行监测是否已经存在</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">newFilename</span><span class="params">( getNewFilename(filename) )</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fullpath;</span><br><span class="line">	<span class="comment">//    遍历搜索路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; searchIt : _searchPathArray) &#123;</span><br><span class="line">        <span class="comment">//这里有一个分辨率搜索顺序的Vector 如果有多套分辨率 下面的资源和脚本路径结构一样可以进行设置，默认为空字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; resolutionIt : _searchResolutionsOrderArray)&#123;</span><br><span class="line">            <span class="comment">//拼接内容 获取字符串内容 同时判断文件是否存在 存在返回全路径</span></span><br><span class="line">            fullpath = <span class="keyword">this</span>-&gt;getPathForFilename(newFilename, resolutionIt, searchIt);</span><br><span class="line">            <span class="keyword">if</span> (!fullpath.empty())&#123;</span><br><span class="line">                <span class="comment">// Using the filename passed in as key. 全路径不为空插入缓存 map 方便下次查找使用</span></span><br><span class="line">                _fullPathCache.insert(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(filename, fullpath));</span><br><span class="line">                <span class="keyword">return</span> fullpath;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isPopupNotify())&#123;</span><br><span class="line">        CCLOG(<span class="string">&quot;cocos2d: fullPathForFilename: No file found at %s. Possible missing file.&quot;</span>, filename.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The file wasn&#x27;t found, return empty string. 找不到返回空字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以看下执行的逻辑和顺序，思考一下别人巧妙的思想。鉴于cocos脚本和资源部分大多数都要走fileUtils ，是不是我们可以做一些更巧妙的东西加入到cocos 的源码中 ？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2018/12/01/Tinypng/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/12/01/Tinypng/" class="post-title-link" itemprop="url">Tinypng</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-01 23:06:18" itemprop="dateCreated datePublished" datetime="2018-12-01T23:06:18+08:00">2018-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%87%92%E4%BA%BA%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">懒人工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>(╯^╰〉错删仓库，以前的blog不见了!!!</p>
<h2 id="tinypng-for-python"><a href="#tinypng-for-python" class="headerlink" title="tinypng for python"></a>tinypng for python</h2><h3 id="首先需要先安装-tinify"><a href="#首先需要先安装-tinify" class="headerlink" title="首先需要先安装 tinify"></a>首先需要先安装 tinify</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install --upgrade tinify</span><br></pre></td></tr></table></figure>

<h3 id="获取tinypng-API-密钥"><a href="#获取tinypng-API-密钥" class="headerlink" title="获取tinypng API 密钥"></a>获取tinypng API 密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import tinify</span><br><span class="line">tinify.key &#x3D; &quot;YOUR_API_KEY&quot;</span><br></pre></td></tr></table></figure>

<p>申请地址    : <a target="_blank" rel="noopener" href="https://tinypng.com/developers">地址</a><br>注意 每一个API_KEY每一个月只能压缩500张图片，如果有需要可以多申请几个备用。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>1.可以选择一个本地文件作为原始图片，压缩后将其写入到另一个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source &#x3D; tinify.from_file(&quot;unpressed_Source_Imag.jpg&quot;)</span><br><span class="line">source.to_file(&quot;outPut_Imag.jpg&quot;)</span><br></pre></td></tr></table></figure>

<p>2.可以上传（二进制字符串）的图像来获得压缩图象数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;unpressed_Source_Imag.jpg&quot;, &#39;rb&#39;) as source:</span><br><span class="line">    source_data &#x3D; source.read()</span><br><span class="line">    result_data &#x3D; tinify.from_buffer(source_data).to_buffer()</span><br></pre></td></tr></table></figure>

<p>3.可以提供一个图片的URL来获取压缩后图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source &#x3D; tinify.from_url(&quot;https:&#x2F;&#x2F;cdn.tinypng.com&#x2F;images&#x2F;panda-happy.png&quot;)</span><br><span class="line">source.to_file(&quot;outPut_Panda_Imag.jpg&quot;)</span><br></pre></td></tr></table></figure>
<p>常用的就这样三种类型，当然如果需要压缩同时更改图片尺寸的话可以翻看官网用法</p>
<h3 id="提供一个可用脚本"><a href="#提供一个可用脚本" class="headerlink" title="提供一个可用脚本"></a>提供一个可用脚本</h3><p><a target="_blank" rel="noopener" href="https://github.com/waitingchange/tinypng">脚本下载地址</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2018/12/01/TexurePacker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/12/01/TexurePacker/" class="post-title-link" itemprop="url">TexurePacker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-01 23:06:11" itemprop="dateCreated datePublished" datetime="2018-12-01T23:06:11+08:00">2018-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%87%92%E4%BA%BA%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">懒人工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>  设想一下，一个游戏有N多图片资源，分为M个文件夹，手动使用TexurePacker打图实在是一个体力活，同时还有忙中出乱的风险。使用脚本批量处理是不二的选择（当前环境为mac）</p>
<h3 id="1-安装-TexturePacker-然后安装-TexturePacker-Command-Line-Tool"><a href="#1-安装-TexturePacker-然后安装-TexturePacker-Command-Line-Tool" class="headerlink" title="1.安装 TexturePacker 然后安装 TexturePacker Command Line Tool"></a>1.安装 TexturePacker 然后安装 TexturePacker Command Line Tool</h3><p><img src="/images/texurepacker_install.png" alt="&quot;install图片&quot;"><br>如上图所示，安装 TexturePacker Command Line Tool</p>
<h3 id="2-打开Teminal-输入-TexturePacker"><a href="#2-打开Teminal-输入-TexturePacker" class="headerlink" title="2.打开Teminal  输入 TexturePacker"></a>2.打开Teminal  输入 TexturePacker</h3><p><img src="/images/texurepacker_teminal.png" alt="&quot;Teminal图片&quot;"><br>​    1.检查是否安装成功<br>​    2.细看 Options:内容的 Output:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--sheet &lt;filename&gt;   要输出的文件的名字       Name of the sheet to write, see texture-format <span class="keyword">for</span> formats available</span><br><span class="line">--texture-format &lt;id&gt;  要输出的图片格式   png、pvr2、pvr2gz、jpg 等   Sets the format <span class="keyword">for</span> the textures.</span><br><span class="line">--data &lt;filename&gt;      plist文件的名字     Name of the data file to write</span><br><span class="line">--format &lt;format&gt;   类型 cocos2d 、unity 等        Format to write, default is cocos2d</span><br><span class="line">--force-publish   忽略hash_key 每次都强制从新输出      Ignore smart update <span class="built_in">hash</span> and force re-publishing of the files</span><br><span class="line">--texturepath &lt;path&gt; 输出路径    Adds the path to the texture file name stored <span class="keyword">in</span> the data file.</span><br><span class="line"> 	--border-padding &lt;int&gt;    图片之间间隔  Sets a padding around each the border, value is <span class="keyword">in</span> pixels, default is 2</span><br><span class="line">--shape-padding &lt;int&gt;   图片形状间隔    Sets a padding around each shape, value is <span class="keyword">in</span> pixels, default is 2</span><br><span class="line">--trim-mode &lt;value&gt; 删除透明像素恢复原始大小，加快渲染 Remove transparent parts of a sprite to shrink atlas size and speed up rendering</span><br><span class="line">                                            None - Keep transparent pixels</span><br><span class="line">                                            Trim - Remove transparent pixels, use original size.</span><br><span class="line">                                            Crop - Remove transparent pixels, use trimmed size, flush position.</span><br><span class="line">                                     CropKeepPos - Remove transparent pixels, use trimmed size, keep position.</span><br><span class="line"></span><br><span class="line">	--basic-sort-by    图片排序     Sort order <span class="keyword">for</span> the sprite list</span><br><span class="line">                                            Best - Best</span><br><span class="line">                                            Name - Name</span><br><span class="line">                                           Width - Width</span><br><span class="line">                                          Height - Height</span><br><span class="line">                                            Area - Area</span><br><span class="line">                                   Circumference - Circumference</span><br><span class="line">--basic-order      方向排序     Sorting direction</span><br><span class="line">                                       Ascending - Ascending</span><br><span class="line">                                      Descending - Descending</span><br><span class="line">--scale &lt;<span class="built_in">float</span>&gt;   缩放          Scales all images before creating the sheet. E.g. use 0.5 <span class="keyword">for</span> half size</span><br><span class="line"> --max-size &lt;int&gt;  最大的尺寸        Sets the maximum width and height <span class="keyword">for</span> the texture <span class="keyword">in</span> auto size mode, default is 2048</span><br><span class="line"> --size-constraints &lt;value&gt; 结纹理进行大小格式化，AnySize 任何大小 POT 使用2次幂  Restrict sizes</span><br><span class="line">                                             POT - Power of 2 (2,4,8,16,32,...)</span><br><span class="line">                                         AnySize - Minimum size</span><br><span class="line">                                            NPOT - Any size but power of 2</span><br></pre></td></tr></table></figure>


<h3 id="3-知道限定条件，那么命令也大概能知道了"><a href="#3-知道限定条件，那么命令也大概能知道了" class="headerlink" title="3.知道限定条件，那么命令也大概能知道了"></a>3.知道限定条件，那么命令也大概能知道了</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">  TexturePacker assets/*.png</span><br><span class="line">        creates out.plist and out.png from all png files <span class="keyword">in</span> assets</span><br><span class="line">        trimming all files and creating a texture with max. 2048x2048px</span><br><span class="line"></span><br><span class="line">  TexturePacker --data main-hd.plist --format cocos2d --sheet main-hd.png assets/*.png</span><br><span class="line">        creates main-hd.plist and main-hd.png from all png files <span class="keyword">in</span> assets</span><br><span class="line">        trimming all files and creating a texture with max. 2048x2048px</span><br><span class="line"></span><br><span class="line">  TexturePacker --scale 0.5 --max-size 1024 --data main-sd.plist --format cocos2d --sheet main-sd.png assets/*.png</span><br><span class="line">        creates main-sd.plist and main-sd.png from all png files <span class="keyword">in</span> assets</span><br><span class="line">        scaling all images to 50%, trimming all files and creating</span><br><span class="line">        a texture with max. 1024x1024px</span><br></pre></td></tr></table></figure>
<h3 id="4-模板有了之后，剩下的就是实现了"><a href="#4-模板有了之后，剩下的就是实现了" class="headerlink" title="4.模板有了之后，剩下的就是实现了"></a>4.模板有了之后，剩下的就是实现了</h3><p>我自己随便写了个脚本，地址  : <a target="_blank" rel="noopener" href="https://github.com/waitingchange/Texurepacker">地址</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2018/08/21/Cocos%20%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/21/Cocos%20%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Cocos 代码执行流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-21 20:37:21" itemprop="dateCreated datePublished" datetime="2018-08-21T20:37:21+08:00">2018-08-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-23 14:53:56" itemprop="dateModified" datetime="2018-12-23T14:53:56+08:00">2018-12-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Cocos/" itemprop="url" rel="index"><span itemprop="name">Cocos</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Cocos对于IOS来讲"><a href="#1-Cocos对于IOS来讲" class="headerlink" title="1.Cocos对于IOS来讲"></a>1.Cocos对于IOS来讲</h1><p>我们知道C语言/C++ 语言的程序入口是 <strong>main</strong> ， IOS 工程一样入口文件在于 <strong>ios/main.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int retVal &#x3D; UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;);</span><br></pre></td></tr></table></figure>

<p>这一行代码解释：IPhone初始化应用程序对象，并且传递给应用需要使用的代理类并初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int UIApplicationMain (</span><br><span class="line">   int argc,</span><br><span class="line">   char *argv[],</span><br><span class="line">   NSString *principalClassName,</span><br><span class="line">   NSString *delegateClassName</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>解释这个函数：第一个，函数传入参数的个数，第二个，参数列表，第三个，UIApplication或其子类的名字，如果设置为nil，默认为UIApplication 第四个，应用程序使用的代理类名，传入以后会进行实例化然后给Application 设置代理。<strong>如果</strong>（principalClassName）为<strong>nil</strong>，程序会从Info.plist中获取，如果Info.plist中没有响应的Key，那么默认是UIApplication</p>
<p>所以main调用以后代码会在 AppController 中执行</p>
<p>因为AppController 是 UIApplicationMain 的代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;这个函数体会显现的比价重要</span><br><span class="line">    &#x2F;&#x2F;cocos Application的单利</span><br><span class="line">    cocos2d::Application *app &#x3D; cocos2d::Application::getInstance();</span><br><span class="line">    &#x2F;&#x2F;中间是一系列的初始化</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;执行了 cocos Application 的run方法</span><br><span class="line">    app-&gt;run();</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们发现 cocos Application 生成单利的时候会发现仅仅是返回了 Application 的单利，没有涉及到构造函数，略微感觉奇怪。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cocos2d application instance  全局静态类对象？</span></span><br><span class="line"><span class="keyword">static</span> AppDelegate s_sharedApplication;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是全局静态类对象，初始化在main函数执行以前，一旦被创建，在程序执行结束以前都不会销毁</p>
<p> <strong>AppDelegate</strong>会不会有一些熟悉？</p>
<p>初始化就会执行下面代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Application* Application::sm_pSharedApplication = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化就执行构造函数，构造函数给单利对象赋值</span></span><br><span class="line">Application::Application()</span><br><span class="line">&#123;</span><br><span class="line">    CC_ASSERT(! sm_pSharedApplication);</span><br><span class="line">    sm_pSharedApplication = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//提供给静态函数调用使用</span></span><br><span class="line"><span class="function">Application* <span class="title">Application::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CC_ASSERT(sm_pSharedApplication);</span><br><span class="line">    <span class="keyword">return</span> sm_pSharedApplication;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到现在这个位置，cocos Application 生成了对象，并且要执行 app-&gt;run();</p>
<p>神秘的地方会在<strong>run()</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Application::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先执行c++部分的 applicationDidFinishLaunching 正是AppDelegate的方法 正是AppDelegate继承于cocos2d::Application</span></span><br><span class="line">    <span class="keyword">if</span> (applicationDidFinishLaunching()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//启动 mainLoop  游戏运转的入口</span></span><br><span class="line">        [[CCDirectorCaller sharedDirectorCaller] startMainLoop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于cocos lua </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AppDelegate::applicationDidFinishLaunching</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化 lua虚拟机然后制定函数的入口部分加入正确的资源搜索路径</span></span><br><span class="line">    <span class="comment">//然后执行 (如果是.lua)</span></span><br><span class="line">    <span class="keyword">if</span> (engine-&gt;executeString(<span class="string">&quot;require(&#x27;src/main&#x27;)&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>lua 虚拟机初始化完毕以后就开始执行了lua 的入口部分 然后执行了启动 mainloop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果认为直接是 Dierctor 执行的mainloop 那么就有一些失望了  CCDirectorCaller 这个才是</span><br><span class="line">[[CCDirectorCaller sharedDirectorCaller] startMainLoop];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-(void) startMainLoop</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;&#x2F; Director::setAnimationInterval() is called, we should invalidate it first</span><br><span class="line">    [self stopMainLoop];</span><br><span class="line">    &#x2F;&#x2F;设置定时器 设置定时回调 doCaller</span><br><span class="line">    displayLink &#x3D; [NSClassFromString(@&quot;CADisplayLink&quot;) displayLinkWithTarget:self selector:@selector(doCaller:)];</span><br><span class="line">    [displayLink setFrameInterval: self.interval];</span><br><span class="line">    [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">-(void) doCaller: (id) sender</span><br><span class="line">&#123;</span><br><span class="line">    cocos2d::Director* director &#x3D; cocos2d::Director::getInstance();</span><br><span class="line">    [EAGLContext setCurrentContext: [(CCEAGLView*)director-&gt;getOpenGLView()-&gt;getEAGLView() context]];</span><br><span class="line">&#x2F;&#x2F;    正常安装60帧每秒进行调用 最终会执行到 熟悉的 Director 的 mainLoop</span><br><span class="line">    director-&gt;mainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最关键的部分来了 <strong>mainLoop</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为啥不是Director </span></span><br><span class="line"><span class="comment">//翻看头文件  class DisplayLinkDirector : public Director  调用父类纯虚函数 执行子类方法 (多态)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayLinkDirector::mainLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//是否销毁Director 在下一帧</span></span><br><span class="line">    <span class="keyword">if</span> (_purgeDirectorInNextLoop)</span><br><span class="line">    &#123;</span><br><span class="line">        _purgeDirectorInNextLoop = <span class="literal">false</span>;</span><br><span class="line">        purgeDirector();</span><br><span class="line">    &#125; <span class="comment">//是否重启Director 在下一帧</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_restartDirectorInNextLoop)</span><br><span class="line">    &#123;</span><br><span class="line">        _restartDirectorInNextLoop = <span class="literal">false</span>;</span><br><span class="line">        restartDirector();</span><br><span class="line">    &#125;<span class="comment">//是否可用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (! _invalid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//核心的部分在于 draw 既然是游戏，那么画布就需要跟黑板一样先擦干净，然后画图案显示 画的足够快(限定氛围内)，动作在人的视觉范围内就是动画</span></span><br><span class="line">        drawScene();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// release the objects  想想这里 AutoreleasePool 关于内存管理的部分 如果没暂停，每一帧结束的时候倾倒池子中的对象</span></span><br><span class="line">        PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/cocos_ios.png" alt="&quot;IOS 执行流程&quot;"></p>
<h3 id="先写到执行mainloop，cocos中每一个对象如何被渲染下次再细讲"><a href="#先写到执行mainloop，cocos中每一个对象如何被渲染下次再细讲" class="headerlink" title="先写到执行mainloop，cocos中每一个对象如何被渲染下次再细讲"></a>先写到执行mainloop，cocos中每一个对象如何被渲染下次再细讲</h3><h1 id="2-对于Cocos-Android-的执行流程"><a href="#2-对于Cocos-Android-的执行流程" class="headerlink" title="2.对于Cocos Android 的执行流程"></a>2.对于Cocos Android 的执行流程</h1><p>如果创建一个空的Android 工程，工程的内容基本包含 AndroidManifest.xml ，Android 逻辑部分 java ，需要的静态资源 res等。</p>
<p>创建一个Cocos 工程同时，Cocos 已经创建了IOS 工程和Android工程, Cocos 的这个Android 工程可以理解为一个空的Android工程</p>
<p>想要知道游戏的启动流程，就需要先知道正常Android 中每一个APP的启动流程</p>
<p>Android 是基于Linux 的，Android 应用安装以后，应用图标可以理解为在一个Launcher 上面挂着，当点击图标的时候  </p>
<p> 1.系统会去调用 **startActivity(Intent) ** </p>
<p> 2.第一次执行 Android  ActivityManagerService 会创建新的进程来实例化目标activity.</p>
<p>把关注点切回到代码部分</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:allowBackup=&quot;true&quot;</span><br><span class="line">    android:icon=&quot;@mipmap/ic_launcher&quot;&gt;</span><br><span class="line">    <span class="comment">&lt;!-- Tell Cocos2dxActivity the name of our .so --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.lib_name&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:value</span>=<span class="string">&quot;cocos2dlua&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Android Activity name and path --&gt;</span></span><br><span class="line">    &lt;activity</span><br><span class="line">        android:name=&quot;org.cocos2dx.lua.AppActivity&quot;</span><br><span class="line">        android:screenOrientation=&quot;landscape&quot;</span><br><span class="line">        android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot; &gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>AndroidManifest.xml 文件暂时可以先理解为配置文件。 Android 系统拿到包名，拿到Activity 文件路径，开始执行Activity 的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppActivity</span> <span class="keyword">extends</span> <span class="title">Cocos2dxActivity</span></span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//执行了java Activity 的初始化   没有额外的新奇的代码了 少点什么 ？还是 ？</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了代码好像什么都没写，但是Cocos 给出的代码就是这样的，是有问题还是 ？</p>
<p>所以 <strong>public class AppActivity extends Cocos2dxActivity</strong> 这句话提醒了我们，AppActivity  继承与 Cocos2dxActivity</p>
<p>想要知道 Cocos2dxActivity 真正具有什么内容，需要看下类本身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cocos2dxActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">Cocos2dxHelperListener</span> </span></span><br></pre></td></tr></table></figure>

<p> 代码部分显示 Cocos2dxActivity 继承于常见的 Activity 和 CocosHelperListener </p>
<p>我们暂时关心的是代码执行的逻辑顺序，于是现在急于知道Cocos2dxActivity的onCreate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="keyword">final</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//国际惯例  super </span></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    onLoadNativeLibraries(); <span class="comment">// 根据manifest 中cocos lib 的名字进行载入so库</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//hadler 构造和初始化</span></span><br><span class="line">    <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> Cocos2dxHandler(<span class="keyword">this</span>);</span><br><span class="line">    Cocos2dxHelper.init(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//设置Layout ...</span></span><br><span class="line">     <span class="keyword">this</span>.init(); <span class="comment">//根据函数命名基本感觉这个比较重要</span></span><br><span class="line">     <span class="comment">// window 啥啥啥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好奇init 函数会有什么惊喜</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// FrameLayout 什么什么的</span></span><br><span class="line">    <span class="comment">// Cocos2dxGLSurfaceView 创建 GLSurfaceView </span></span><br><span class="line">    <span class="keyword">this</span>.mGLSurfaceView = <span class="keyword">this</span>.onCreateView();</span><br><span class="line"> 	<span class="comment">// 设置渲染 创建渲染  这里面会有什么特别的 ？</span></span><br><span class="line">    <span class="keyword">this</span>.mGLSurfaceView.setCocos2dxRenderer(<span class="keyword">new</span> Cocos2dxRenderer());</span><br><span class="line">    <span class="keyword">this</span>.mGLSurfaceView.setCocos2dxEditText(edittext);</span><br><span class="line">    <span class="comment">// Set framelayout as the content view</span></span><br><span class="line">    setContentView(mFrameLayout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new Cocos2dxRenderer() 这个会让我感兴趣，创建了一个render ，这个render 里面会做什么 ？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cocos2dxRenderer</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span> // 就是<span class="title">Gl</span> 需要用到的<span class="title">render</span></span></span><br><span class="line"><span class="class">   ...</span></span><br><span class="line"><span class="class">        @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">onSurfaceCreated</span>(<span class="title">final</span> <span class="title">GL10</span> <span class="title">GL10</span>, <span class="title">final</span> <span class="title">EGLConfig</span> <span class="title">EGLConfig</span>) </span>&#123;</span><br><span class="line">    	<span class="comment">//根据宽高进行初始化内容  nativeInit 会比较感兴趣 这块最终是调用到c++ 部分 jni 调用</span></span><br><span class="line">        Cocos2dxRenderer.nativeInit(<span class="keyword">this</span>.mScreenWidth, <span class="keyword">this</span>.mScreenHeight);</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(<span class="keyword">final</span> GL10 GL10, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//猜想会根据gl 给出的宽高进行c++ 内部的更改逻辑</span></span><br><span class="line">        Cocos2dxRenderer.nativeOnSurfaceChanged(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(<span class="keyword">final</span> GL10 gl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       	 * 游戏每一帧渲染开始入口</span></span><br><span class="line"><span class="comment">         * No need to use algorithm in default(60 FPS) situation,</span></span><br><span class="line"><span class="comment">         * since onDrawFrame() was called by system 60 times per second by default.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sAnimationInterval &lt;= <span class="number">1.0</span> / <span class="number">60</span> * Cocos2dxRenderer.NANOSECONDSPERSECOND) &#123;</span><br><span class="line">            <span class="comment">//每一帧执行的入口。 所以会不会跟MainLoop 一样 ？</span></span><br><span class="line">            Cocos2dxRenderer.nativeRender();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> interval = now - <span class="keyword">this</span>.mLastTickInNanoSeconds;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (interval &lt; Cocos2dxRenderer.sAnimationInterval) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((Cocos2dxRenderer.sAnimationInterval - interval) / Cocos2dxRenderer.NANOSECONDSPERMICROSECOND);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Render time MUST be counted in, or the FPS will slower than appointed.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">this</span>.mLastTickInNanoSeconds = System.nanoTime();</span><br><span class="line">            Cocos2dxRenderer.nativeRender();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从点击icon 到Activity 的初始化，程序做了这么一些事情 </p>
<ol>
<li>Activity 的onCreate  </li>
<li>Activity 的父类的 onCreate</li>
<li>Activity 父类的 init()</li>
<li>Cocos Render 对象的初始化</li>
<li>Cocos Render 对象初始化以后 调用 nativeInit</li>
<li>每一帧调用c++ 部分的nativeRender</li>
</ol>
<p><strong>下面是nativeInit</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> <span class="title">Java_org_cocos2dx_lib_Cocos2dxRenderer_nativeInit</span><span class="params">(JNIEnv*  env, jobject thiz, jint w, jint h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> director = cocos2d::Director::getInstance(); </span><br><span class="line">    <span class="keyword">auto</span> glview = director-&gt;getOpenGLView();</span><br><span class="line">    <span class="keyword">if</span> (!glview)</span><br><span class="line">    &#123;</span><br><span class="line">        glview = cocos2d::GLViewImpl::create(<span class="string">&quot;Android app&quot;</span>);</span><br><span class="line">        glview-&gt;setFrameSize(w, h);</span><br><span class="line">        director-&gt;setOpenGLView(glview);</span><br><span class="line">        cocos2d::Application::getInstance()-&gt;run(); <span class="comment">// android 部分的 执行c++ 的Run()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cocos2d::GL::invalidateStateCache();</span><br><span class="line">        cocos2d::GLProgramCache::getInstance()-&gt;reloadDefaultGLPrograms();</span><br><span class="line">        cocos2d::DrawPrimitives::init();</span><br><span class="line">        cocos2d::VolatileTextureMgr::reloadAllTextures();</span><br><span class="line">        <span class="function">cocos2d::EventCustom <span class="title">recreatedEvent</span><span class="params">(EVENT_RENDERER_RECREATED)</span></span>;</span><br><span class="line">        director-&gt;getEventDispatcher()-&gt;dispatchEvent(&amp;recreatedEvent);</span><br><span class="line">        director-&gt;setGLDefaultValues();</span><br><span class="line">    &#125;</span><br><span class="line">    cocos2d::network::_preloadJavaDownloaderClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面是nativeRender</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_org_cocos2dx_lib_Cocos2dxRenderer_nativeRender</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    cocos2d::Director::getInstance()-&gt;mainLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/cocos_android.png" alt="&quot;IOS 执行流程&quot;"></p>
<p>当IOS 和Android 部分执行到Mainloop ， 启动的差异就已经被屏蔽了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">change</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
