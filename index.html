<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"waitingchange.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="仓库坏了，丢了一些内容">
<meta property="og:type" content="website">
<meta property="og:title" content="懒人的胡言乱语">
<meta property="og:url" content="https://waitingchange.github.io/index.html">
<meta property="og:site_name" content="懒人的胡言乱语">
<meta property="og:description" content="仓库坏了，丢了一些内容">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="change">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://waitingchange.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>懒人的胡言乱语</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">懒人的胡言乱语</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="change"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">change</p>
  <div class="site-description" itemprop="description">仓库坏了，丢了一些内容</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/waitingchange" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;waitingchange" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:waiting0313@gmail.com" title="E-Mail → mailto:waiting0313@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/08/17/iOS%E5%AE%A1%E6%A0%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/iOS%E5%AE%A1%E6%A0%B8/" class="post-title-link" itemprop="url">iOS审核</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-08-17 23:10:13 / 修改时间：23:13:43" itemprop="dateCreated datePublished" datetime="2021-08-17T23:10:13+08:00">2021-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%AE%A1%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">iOS审核</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="iOS审核"><a href="#iOS审核" class="headerlink" title="iOS审核"></a>iOS审核</h1><h2 id="因为内容透露过多，暂时关闭本类型，如需详细内容请与我联系"><a href="#因为内容透露过多，暂时关闭本类型，如需详细内容请与我联系" class="headerlink" title="因为内容透露过多，暂时关闭本类型，如需详细内容请与我联系"></a>因为内容透露过多，暂时关闭本类型，如需详细内容请与我联系</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/07/26/iOS-image-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/26/iOS-image-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">iOS image 内存优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-26 16:25:44 / 修改时间：20:32:13" itemprop="dateCreated datePublished" datetime="2021-07-26T16:25:44+08:00">2021-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">内存优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="iOS-Image-内存优化"><a href="#iOS-Image-内存优化" class="headerlink" title="iOS Image 内存优化"></a>iOS Image 内存优化</h1><img src="/2021/07/26/iOS-image-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/ios_image_buffer.png" style="zoom:67%;">

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在iOS 原生层，对于图片的使用，推荐使用 <strong>UIGraphicsImageRenderer</strong> API </p>
<p>也需要合理在不同的使用场景，根据场景需要类型使用正确的API ，同时对图片资源做加载和释放管理。</p>
<h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>看看上面的这个图，有没有考虑过，iOS 里面一张 <code>4096 * 3072</code> 尺寸的<code>png</code>图片占用多大内存呢 ？答案是惊人的 <strong>48M</strong></p>
<p>计算公式是这样的 <code>image width * image height * 4 /1024 / 1024</code>  这里认为 image 属于RGBA8888 </p>
<h2 id="问题来了，内存都在哪里-？"><a href="#问题来了，内存都在哪里-？" class="headerlink" title="问题来了，内存都在哪里 ？"></a>问题来了，内存都在哪里 ？</h2><p>深究一下iOS 内存分配逻辑可以有下面的结论，iOS 内存部分分为三类，即：<code>Data Buffer、Image Buffer、Frame Buffer</code></p>
<p><code>Data Buffer </code>是存储在内存中的原始数据，图像可以使用不同的格式保存，如 jpg、png。是Image 的文件内容。</p>
<p><code>Image Buffer</code> 是图像在内存中的存在方式，用于存放图像具体素点信息。<code>Image Buffer</code> 的大小和图像的大小成正比。</p>
<p><code>Frame Buffer</code> 和 <code>Image Buffer</code> 内容相同，不过其存储在 vRAM（video RAM）中，而 Image Buffer 存储在 RAM 中。</p>
<p>解码就是从 <code>Data Buffer </code>生成 <code>Image Buffer </code>的过程。<code>Image Buffer</code> 会占用带宽上传到 <code>GPU</code> 成为 <code>Frame Buffer</code>，最后GPU负责使用 <code>Frame Buffer</code>用于更新显示区域。</p>
<img src="/2021/07/26/iOS-image-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/ios_image_render.png" style="zoom:67%;">

<p>大致执行流程如上图，先经过载入，加载图像内容到内存成为Data Buffer ， 然后就是经过Decode 过程，转化图像为GPU 可用的 Image Buffer ，在需要显示的时候Image Buffer data 会被上传到GPU 中成为Frame Buffer Data 进行相应渲染。</p>
<p>上图飙升的 48M 内存代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原图加载</span><br><span class="line">-(void)test</span><br><span class="line">&#123;</span><br><span class="line">    UIImageView *imageView &#x3D; [[UIImageView alloc]init];</span><br><span class="line">    UIImage *image &#x3D; [UIImage imageNamed:@&quot;bg_teacherLetter&quot;];</span><br><span class="line">    imageView.image &#x3D; image;</span><br><span class="line">    imageView.frame &#x3D; CGRectMake(0, 0, 1367*0.5, 1089*0.5);</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>UIImage</code> 是 iOS 中处理图像的高级类。创建一个 UIImage 实例只会加载 Data Buffer，将图像显示到屏幕上才会触发解码，也就是 Data Buffer 解码为 Image Buffer。Image Buffer 也关联在 UIImage 上。</p>
<p><code>imageNamed</code> 这个常用API 存在一个内存问题，就是载入以后图片会被缓存到系统Cache 里面。 这是一种便捷的设计，比如可以快速在cache 里面查找到图片的缓存，同时也是一个弊端，内存就放在了cache 里面，一部分内存就会被持续占用。如果是比较小，又常用的图片，这么处理比较合适，但是针对于例子中的尺寸来讲，就非常不合适。</p>
<p>对于这个问题，大家通用的解决方案应该是 使用 imageWithContentsOfFile这个 API 来搞，根据苹果的解释是：使用这个方法创建的图片不会缓存于系统缓存内，开发者可在适当的时机对图片进行处理。因而，对于一些比较大的或不常使用的图片，我们应当使用<code>imageWithContentsOfFile:</code>进行创建。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)withContexOfFile&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">    <span class="built_in">UIImage</span> *image =   [ViewController imageWithContentName:<span class="string">@&quot;bg_teacherLetter@2x.png&quot;</span>];</span><br><span class="line">    imageView.image = image;</span><br><span class="line">    imageView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1367</span>*<span class="number">0.5</span>, <span class="number">1089</span>*<span class="number">0.5</span>);</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:imageView];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithContentName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:name ofType:<span class="literal">nil</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/07/26/iOS-image-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/ios_image_render_with.png" style="zoom:67%;">

<p>API 的本身用途是不在cache  里面缓存图片内容，但是图片占用的内存依然很大。</p>
<p><strong>优点</strong> : 图片不使用即释放内存，不存在图片常驻内存<br><strong>缺点</strong> : 每次使用都需要做IO的操作</p>
<p>适用于使用不频繁的大图加载</p>
<h2 id="有没有更好的方式来降低图片内存-？"><a href="#有没有更好的方式来降低图片内存-？" class="headerlink" title="有没有更好的方式来降低图片内存 ？"></a>有没有更好的方式来降低图片内存 ？</h2><p>答案，有！ 参考 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/219/">Image and Graphics Best Practices</a>   WWDC2018</p>
<p>所以引出这里的重点： <strong>UIGraphicsImageRenderer</strong></p>
<p>代码先：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(void)resizeTest</span><br><span class="line">&#123;</span><br><span class="line">        UIImageView *imageView &#x3D; [[UIImageView alloc]init];</span><br><span class="line">        UIImage *image &#x3D; [UIImage imageNamed:@&quot;bg_teacherLetter&quot;];</span><br><span class="line">        image &#x3D; [self resiImage:image size:CGSizeMake(1367*0.5, 1089*0.5)];</span><br><span class="line">        imageView.image &#x3D; image;</span><br><span class="line">        imageView.frame &#x3D; CGRectMake(0, 0, 1367*0.5, 1089*0.5);</span><br><span class="line">        [self.view addSubview:imageView];</span><br><span class="line">&#125;</span><br><span class="line">- (UIImage*)resiImage:(UIImage *)image size:(CGSize)size&#123;</span><br><span class="line">    UIGraphicsImageRenderer *re &#x3D; [[UIGraphicsImageRenderer alloc]initWithSize:size];</span><br><span class="line">    return [re imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull rendererContext) &#123;</span><br><span class="line">        [image drawInRect:CGRectMake(0, 0, size.width, size.height)];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先给出一组数据对比  图片尺寸同样缩放在 1367 / 2 , 1089 / 2</p>
<p>图1 使用 imageNamed  API , 发现 Physical footprint 明显增加了 48M， 内存块儿在 <strong>IOSurface</strong></p>
<img src="/2021/07/26/iOS-image-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/ios_image_render_normal.png" style="zoom:67%;">

<p><strong>IOSurface</strong> 内存块儿增加是因为 图片decode 之后生成的位图，内存会被分类到这里</p>
<p>图2 使用 UIGraphicsImageRenderer  API </p>
<img src="/2021/07/26/iOS-image-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/ios_image_render_phy.png" style="zoom:67%;">

<p>明显观察到的内容是 占用巨大的 <strong>IOSurface</strong> 不存在了，但是内存块儿多了一个 <strong>CG raster data</strong> 大小为 5824K</p>
<p><code>1367 *  1089 * 4  / 1024  =  5815.08984375</code> 跟 5824 很接近是不是 ？ 可是又会有一点儿感觉不对，图片的宽和高都没有按照缩放的size 进行计算。于是就这个问题又去查了一下。</p>
<p>UIGraphicsImageRenderer 实现的原理是，系统可以根据图片分辨率选择创建解码图片的格式，如选用SRGB format 格式，每个像素占用 4 字节，而Alpha 8 format，每像素只占用 1 字节，因此可以减少大量的解码内存占用。</p>
<p>使用 UIGraphicsImageRenderer 之后这张图片physical footprint增加了多少内存 ？ 0.2M</p>
<p>那么优化了多少内存呢 (48 - 0.2) / 48  = 0.996 , 释放了 96% 的可用空间。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/07/08/C-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%B8%9A%E5%8A%A1%E5%AE%9E%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/C-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%B8%9A%E5%8A%A1%E5%AE%9E%E4%BE%8B/" class="post-title-link" itemprop="url">C++ 跨平台业务实例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-08 17:58:27 / 修改时间：18:26:46" itemprop="dateCreated datePublished" datetime="2021-07-08T17:58:27+08:00">2021-07-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-跨平台业务相关实例"><a href="#C-跨平台业务相关实例" class="headerlink" title="C++ 跨平台业务相关实例"></a>C++ 跨平台业务相关实例</h1><p><img src="/2021/07/08/C-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%B8%9A%E5%8A%A1%E5%AE%9E%E4%BE%8B/static_lib.png" alt="static_lib"></p>
<h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>我们业务方有多端：iOS 、Android 、win、Mac 。于是需要使用跨平台统一的相关业务功能。</p>
<p>现状是存在多端的开发人员，多个技术栈，如果加上管理和沟通不畅，一个需求会有多个版本。以最好的状态来估计，出现不同的逻辑但是业务都正常是有可能的。但是只要有人员介入参与项目开发，出现问题是必然的。如何查找和后期稳定维护将是一个巨大的灾难。</p>
<p>那么如果使用C++来作为基础业务开发，好处是显而易见的，即直接编译成为二进制，速度优势明显。但是缺陷是，如果开发人员出现了很小的失误，带来的问题是巨大的，毕竟太多的用户不太愿意升级App</p>
<h2 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h2><p>正常来讲，C++ 在跨平台游戏引擎中比较常见。也因为业务需要分端开发的成本比较高，C++ 作为底层通用组件对于跨平台应用来讲是一个不错的选择。根据这一点简单讲一下如何才能使用一套代码进行四端编译。</p>
<p>需要先科普一下静态库和动态库。</p>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。</p>
<p>静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib/.tbd）。与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。</p>
<p>动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作<strong>共享库</strong>）。</p>
<p>我们知道动态库有各种好处，比如包体比较小，可以被多个库使用等，但是由于iOS 在审核时候对于动态库是不持推荐态度，而且，需要依赖系统环境等。</p>
<p>我们有一个原生需求，就是使用C++ 版本的Websocket， 使用底层提供公共功能。</p>
<h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>在GitHub 上面，根据排名列了一下顺序。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zaphoyd/websocketpp"><em>websocketpp</em></a>  4.8K star</p>
<p><a target="_blank" rel="noopener" href="https://github.com/boostorg/beast">boostorg/beast</a>  3.1K star</p>
<p><a target="_blank" rel="noopener" href="https://github.com/warmcat/libwebsockets">warmcat/<em>libwebsockets</em></a>  3.1K star</p>
<p>以稳定和快速开发，采用了websocketpp 。 没有采用 libwebsocket 的另外一个原因是，在比较少的示例代码中，查找异常出现的错误码都是一件极为难的事情。</p>
<p><strong>websocketpp</strong> 这个库没什么特别大的问题，唯一的问题是需要依赖boost 库，生成二进制比较大。</p>
<p>问题呢都不是很大，吭哧吭哧的搞好几天，boost 相关依赖环境和相关编译环境就配置好了，下一步就是如何生成相应的静态库。</p>
<p><img src="/2021/07/08/C-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%B8%9A%E5%8A%A1%E5%AE%9E%E4%BE%8B/Websocket_framework.png"></p>
<p>项目比较特殊，遗留问题，游戏引擎部分选择了不开源的Laya . 又因为业务侧，laya 自己封装的libWebsocket 在遇到相关网络问题的时候力不重新，所以才会有使C++ 版本Websocket 来替换掉 Laya 提供的Websocket 的需求。</p>
<p>结构如需求，很简单，通过基础boost 提供基础相关能力，在上层去扩充子插件。通过插件提供的基础能力，封装相应接口暴露给上层去使用。</p>
<p>因为本身项目的问题，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/06/24/Appium%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/24/Appium%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4/" class="post-title-link" itemprop="url">Appium 自动化测试验证步骤</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-24 18:37:23" itemprop="dateCreated datePublished" datetime="2021-06-24T18:37:23+08:00">2021-06-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-21 14:40:12" itemprop="dateModified" datetime="2021-07-21T14:40:12+08:00">2021-07-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">自动化测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Appium-自动化测试验证步骤"><a href="#Appium-自动化测试验证步骤" class="headerlink" title="Appium 自动化测试验证步骤"></a>Appium 自动化测试验证步骤</h1><img src="/2021/06/24/Appium%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4/PrefDogDemo.png" alt="Memary Guage increase" style="zoom:67%;">     

<p>目的：</p>
<p>​    为了自动化测试APP，想要高效验证内容</p>
<p>已知：</p>
<p>​    可用有，PrefDog ，Appium， 且PrefDog 已经有完善的相关自动化脚本</p>
<p>存在问题：</p>
<p>​    自动化在于教师端，需要操作教师端，客户端用于性能验证，单一的监听</p>
<p>​    我们要求肯定不能满足于这样，我需要客户端自动操作，用于验证内容。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    Appium 对于iOS 自动化测试很好用，但是对于我们的Hybrid类型App 似乎不是特别好用。</p>
<h2 id="折腾步骤"><a href="#折腾步骤" class="headerlink" title="折腾步骤"></a>折腾步骤</h2><ol>
<li><p>新电脑，安装环境啥的，因为网上有太多的安装教程，这里不想多说。<a target="_blank" rel="noopener" href="https://www.mdnice.com/writing/4e97216fd50442898ad2d0c6c7e71ed9">Appium Mac 安装教程</a></p>
</li>
<li><p>给设备安装 <code>WebDriverAgent</code> 推荐去Appium 的安装包下面去运行， 具体的方法参考</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-WebDriverAgent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 里面是xcode 工程 打开，先编译库，在编译iOS 工程， 注意签名  最后安装设备     <span class="built_in">command</span> + u</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打开Appium 客户端，配置如下</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;platformName&quot;</span>: <span class="string">&quot;ios&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;platformVersion&quot;</span>: <span class="string">&quot;13.6&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;udid&quot;</span>: <span class="string">&quot;eac242486bcffe0d9fcc233bce4b5f52ec4df738&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;deviceName&quot;</span>: <span class="string">&quot;iPad&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;automationName&quot;</span>: <span class="string">&quot;XCUITest&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;bundleId&quot;</span>: <span class="string">&quot;com.xxxxxx.xxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;xcodeOrgId&quot;</span>: <span class="string">&quot;4xxxxZ3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;xcodeSigningId&quot;</span>: <span class="string">&quot;iPhone Developer&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/06/24/Appium%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4/appium config.png" alt="Memary Guage increase" style="zoom:67%;">

<ol start="4">
<li><p>点击 <code>Start Session</code>  前提 Xcode  在运行当前 WebDriverAgent    ，然后 Appium 会自动拉起设备上指定的bundleId App</p>
<img src="/2021/06/24/Appium%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4/appium_test.png" alt="Memary Guage increase" style="zoom:67%;"></li>
</ol>
<p>问题来了，发现App Source 里面没有我们想要的button 之类的，因为没有特殊id 就没办法进行相应自动化。我们的项目是给予Laya Native 的App ， 显示区域是JavaScript 调用GLKView进行绘制，所以，抓不到iOS UI 控件应该是正常的。</p>
<h3 id="有没有其他方式"><a href="#有没有其他方式" class="headerlink" title="有没有其他方式"></a>有没有其他方式</h3><p>在准备宣布说无法调试Laya JavaScript 的时候，我看到了这个 appium 使用<a target="_blank" rel="noopener" href="https://github.com/google/ios-webkit-debug-proxy">ios_webkit_debug_proxy</a>。</p>
<p>感觉我又有了希望，安装步骤依然忽略，安装以后配置appium</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;platformName&quot;</span>: <span class="string">&quot;ios&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;platformVersion&quot;</span>: <span class="string">&quot;13.6&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;udid&quot;</span>: <span class="string">&quot;eac242486bcffe0d9fcc233bce4b5f52ec4df738&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;deviceName&quot;</span>: <span class="string">&quot;iPad&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;automationName&quot;</span>: <span class="string">&quot;XCUITest&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;xcodeOrgId&quot;</span>: <span class="string">&quot;4XXXXXX3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;xcodeSigningId&quot;</span>: <span class="string">&quot;iPhone Developer&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;startIWDP&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;browserName&quot;</span>: <span class="string">&quot;Safari&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够完美拉起 Safari ， 也能看到Safari 里面的标签内容，但是不是我们想要的App 内容</p>
<img src="/2021/06/24/Appium%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4/appium_safari.png" alt="Memary Guage increase" style="zoom:67%;">

<p>相关配置放到Appium 里面是可以直接拉起Safari 的，但是不能拉起我们指定的App</p>
<p>瞅了一下Appium 关于 hybrid App的测试例子，大多数是使用了Webview 技术来profile 相关HTML Context 内容。这个跟我们现有项目不符，验证到此可以结束了。</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>Appium 确实是一个很优秀的自动化测试框架，可以通过大家熟知的语言进行相关自动化测试，能够非常方便的提高测试的效率，增加测试结果的可靠性。这一切都需要针对正常的iOS或者Android App ， 对于 hybrid App 也有非常不错的测试方式，相关测试代码也是非常的简洁。对于正常类型App 测试，强烈推荐。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">iOS 内存分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-18 14:05:09" itemprop="dateCreated datePublished" datetime="2021-06-18T14:05:09+08:00">2021-06-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-06 18:13:28" itemprop="dateModified" datetime="2021-07-06T18:13:28+08:00">2021-07-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">内存优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="iOS-内存分析"><a href="#iOS-内存分析" class="headerlink" title="iOS 内存分析"></a>iOS 内存分析</h1><img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/Memary Guage increase.png" alt="Memary Guage increase" style="zoom:67%;">        

<p>​        最近在做关于APP 内存方面的分析,去尽量优化iOS 侧 APP 的内存。原本使用的是之前自己掌握的方式，比如 <code>Memory leaks , Memory Allocations</code> 每一项工具都有针对性的内容，在进一步优化的时候发现了原来可以使用终端方式来查询问题。一个对于自己全新的领域。</p>
<p>​        引述一下关键字：<strong>iOS Memory Deep Dive</strong>      <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/416/">WWDC2018</a> </p>
<p>​        WWDC2018 ， 2018年 。大概如果是苹果开发铁杆粉都已经悉数掌握。但是很多开发者似乎对这块儿知识都了解较少，如何具体使用也不一定都能掌握。我这儿整理一下对自己查找问题中的一些相关性，也顺带做一下总结，提醒一下自己。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        利用自己在实际开发中遇到的相关问题来具体讲解如何在iOS中做内存分析，怎样去针对性优化。</p>
<ul>
<li><p>怎样去观察内存占用</p>
</li>
<li><p>需要卸载掉哪些内存</p>
</li>
</ul>
<h4 id="怎样观察内存"><a href="#怎样观察内存" class="headerlink" title="怎样观察内存"></a>怎样观察内存</h4><p>​        大家都在Xcode 下经常开发，<strong>Xcode Memory gauge</strong> 这个界面大家应该都不会陌生</p>
<img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/Memary Guage.png" alt="Memary Guage" style="zoom: 67%;">

<p>​        在当前界面，能够提供数字，百分比，内存使用危险程度的通用观察界面。针对于平常查看内存占用大小比较方便，但是对于内存问题，这块儿能提供的内容相当有限。但是能够提示开发者内存占用的波动，从而引起关注。</p>
<h2 id="iOS-内存介绍"><a href="#iOS-内存介绍" class="headerlink" title="iOS 内存介绍"></a>iOS 内存介绍</h2><p>​        <strong>iOS Memory Deep Dive</strong> 讲了关于iOS 在内存方面的使用和统计方式。提到了在iOS 操作系统中，内存的统计方式是按照分页的方式。内存又会被细分为 物理内存 和虚拟内存。 APP 的运行是一定要基于内存之上的，物理内存和虚拟内存的主要作用如下。</p>
<p>​        <strong>物理内存</strong>：设备运行时为操作系统和各种程序提供临时储存空间</p>
<p>​        <strong>虚拟内存</strong>：为每一个进程提供了一个<strong>一致的、私有的地址空间</strong>；其主要作用是：保护了每个进程的地址空间不会被其他进程破坏，降低内存管理的复杂性。 虚拟内存是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中。</p>
<p>​        iOS系统是按页分配内存的，每个page通常是16KB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Memory in use &#x3D; Number of pages * Page size</span><br></pre></td></tr></table></figure>

<p>​        iOS内存可以分为clean memory和dirty memory。当用户(也就是程序员)申请分配内存时，系统只会对这块内存进行标记，这时只会分配虚拟内存，而不会分配物理内存，此时内存是clean memory。当对这块内存进行数据填充时，才会分配物理内存，内存变为dirty memory。</p>
<img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/dirty_memory.png" alt="dirty_memory" style="zoom:67%;">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Memory Footprint &#x3D; Dirty Memory + Compressed Memory</span><br></pre></td></tr></table></figure>

<p>针对内存问题，我们考虑的重点也是去减少 <code>Dirty Memory</code></p>
<h2 id="具体查找步骤"><a href="#具体查找步骤" class="headerlink" title="具体查找步骤"></a>具体查找步骤</h2><p>根据已知的信息，尝试去实践一下如何查找内存消耗，这次使用命令行方式。</p>
<p>以第一张图 27.8M 为例。首先修改 iOS Scheme ， 勾选 <code>Malloc Stack Logging</code> 并选中为 <code>Live Aloocations Only</code></p>
<img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/ios_scheme.png" alt="ios_scheme" style="zoom:50%;">

<p>然后就是运行中等待时机到来，点击<code>Debug Memory Graph</code> 得到内存图。可以通过 <code>File  --&gt;  Export Memory Graph</code>到处文件到指定位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#终端执行下面代码</span><br><span class="line">$  vmmap -summary memory.memgraph   # 首先获取内存分配的概况，使用这条命令可以获得</span><br></pre></td></tr></table></figure>

<img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/vmmap_summary.png" alt="vmmap_summary" style="zoom:50%;">

<p>从我们已知的信息可以知道 ， Dirty Memory 是我们关注的重点。于是发现了 REGION TYPE 是 MALLOC_LARGE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vmmap -verbose memory.memgraph | grep &quot;MALLOC_LARGE&quot;  #获取详细的关于内存分配的 在归属于 “MALLOC_LARGE” 这里的内容</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/vmmap_verbose.png" alt="vmmap_verbose"></p>
<p>从图中我们可以容易的发现，内存地址为 0x1146e4000 。 在这样的情况下，我们可以借助于另外一个命令 <code>malloc_history</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ malloc_history memory.memgraph -fullStacks 0x1146e4000   # 获取地址块儿的堆栈信息</span><br></pre></td></tr></table></figure>

<img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/malloc_history.png" alt="malloc_history" style="zoom:50%;">

<p>根据我们查到的调用堆栈，我们发现是因为 new 操作，导致了内存分配，源头应该在于 InstanceDemo 这个类的构造函数。</p>
<img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/source_code.png" alt="source_code" style="zoom: 50%;">        

<p>贴上源码，是这里引起的内存分配无疑。我们同时也发现，Dirty memory 也是 9.8M.   如果我们不给数组赋值呢？</p>
<p>我们注释掉数组赋值，重新走一遍儿上面的流程。</p>
<img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/vmmap_summary_new.png" alt="vmmap_summary_new" style="zoom:50%;">

<p>于是发现了，同样 <code>MALLOC_LARGE</code> 中的 VIRTUAL SIZE 是 10M ， 但是DIRTY SIZE 只剩下了 208K</p>
<p>如果我们细跟入进去会发现</p>
<img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/malloc_history_new.png" alt="malloc_history_new" style="zoom:50%;">

<p>是同样能够查到内存分配的位置。但是因为只有内存申请，没有使用，分配的区域被放在了虚拟内存，所以Dirty MEMARY 并没有相应标记。</p>
<p>在查询内存问题的时候还有另外一个命令可以使用，就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ leaks -traceTree  0x1118cc000 memory_new.memgraph</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/18/iOS-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/leaks_tool.png" alt="leaks_tool"></p>
<p>通过这个命令可以知道 m_instance 被持有引用，可能会出现内存泄漏。</p>
<p>Demo 依旧会提供，主要对内存如何分析和查找可能性提出一些方法。 我们同时还可以通过Xcode 提供的 VM Tracker 等工具用来具体指向我们怀疑的点。一般来讲，图片资源占用的内存会比较大，如果作为优化的方向，首选见效处理就是规范化图片资源。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/" class="post-title-link" itemprop="url">Laya Native 性能分析和改造笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 17:16:28" itemprop="dateCreated datePublished" datetime="2021-06-04T17:16:28+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-13 18:47:12" itemprop="dateModified" datetime="2021-07-13T18:47:12+08:00">2021-07-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">内存优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Laya-Native-性能分析和改造笔记"><a href="#Laya-Native-性能分析和改造笔记" class="headerlink" title="Laya Native 性能分析和改造笔记"></a>Laya Native 性能分析和改造笔记</h1><p>分析和修改步骤：</p>
<p>1、使用laya编辑器 ， 2.1.0 版本的，导出生成 2.1.0 版本的ios 工程为基础</p>
<p>为了验证编译导出的laya 二进制文件能否放入到低版本，先对2.1.0 版本ios 工程做了以下修改</p>
<p>改动部分如下：</p>
<ol>
<li>替换laya脚本导出的 libconch.a 文件</li>
<li>替换高版本（2.11.0）apploader.js , index.js ,挪动版本 webglPlus.js 到低版本工程</li>
</ol>
<p>改动后代码可以直接正常运行。</p>
<p>profile 内存使用情况 （更换后,游戏运行状态） 170M （现象，也同时证明laya已有js 代码可以直接运行在Laya 高版本运行环境）</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled.png"></p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>在直接更改iOS源码，强制卸载laya部分，表现如下，内存并没有如预期下降。</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%201.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%201.png"></p>
<p>在profile 里面去查找还持有，存在于内存的一些对象，可以发现如下（两个占用内存的大户）</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%202.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%202.png"></p>
<p>把相关退出代码搬运到 laya 提供的项目工程中，通过debug方式profile ，能够看到每次重新进入laya 内存部分被重新分配了 30+ M  （每一次都会增加，认定引擎侧出现内存泄漏，在于C++或者ObjectC）</p>
<p>比如可以很直观发现下面的泄漏。</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%203.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%203.png"></p>
<p>优先解决内存占用大户，发现特征是如下，不能指向具体的代码片段，但是也提供了相应的信息，libglxxxx 推测是在OpenGL 侧。（可能是C++ 持有，属于重点怀疑，但是这个库又是iOS自己提供，所以ObjectC 也不能排除）</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%204.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%204.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%205.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%205.png"></p>
<p>在一次profile 时候，在资源载入的时候发现了JCLayaGl  和texture2d 的字段，所以怀疑为C++ 本身内存泄漏的可能性又在加强。libglxxxx 这个东西依然存在，可以先做排除法，先不去管texure2d这块儿。</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%206.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%206.png"></p>
<p>不使用texure2d的最直接方式是不给图片资源，于是，更换为无图片资源小游戏demo，测试如下</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%207.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%207.png"></p>
<p>依然存在大量的 Gl 字段， 而且还能看到很多 allocated pair to attach …   这货又好像是iOS的内存泄漏</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%208.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%208.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%209.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%209.png"></p>
<p>所以基本认定，在iOS Object C 侧，卸载部分存在内存泄漏，在C++侧也大致会存在相应的内存泄漏。那么下面面临的问题就是如何修复。</p>
<p>C++通用内存泄漏部分基本是在于 Init 或者 构造函数 中 new 出一些对象，在析构时候没有干掉，导致一些内存常驻。</p>
<p>Object C 里面也有C++ 类似的地方，alloc 出对象，然后强制引用，导致对象不能正常释放。</p>
<p>所以基本解决的思路就有了，下一步，干活验证。</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2010.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2010.png"></p>
<p>ios 如下图，现有学生端 profile 内存部分，也能找到在上面魔改的Demo 工程中出现的内存消耗大户，所以laya 本身存在 destory 接口，但是内部逻辑却没有做到位。既然有，那么我们强制析构对象的时机和入口就很明确了。</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2011.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2011.png"></p>
<h2 id="测试内存和性能比对："><a href="#测试内存和性能比对：" class="headerlink" title="测试内存和性能比对："></a>测试内存和性能比对：</h2><p>替换修改好的laya二进制到学生端    卸载前</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2012.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2012.png"></p>
<p>卸载后</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2013.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2013.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2014.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2014.png"></p>
<p>明显看到内存能够降下去！！！</p>
<h2 id="具体内存和性能对比"><a href="#具体内存和性能对比" class="headerlink" title="具体内存和性能对比"></a>具体内存和性能对比</h2><p>laya 两个版本运行时内存比较</p>
<h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2015.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2015.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2016.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2016.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2017.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2017.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2018.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2018.png"></p>
<h3 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h3><p>旧有的占用内存量</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2019.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2019.png"></p>
<p>点击切换，干掉laya</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2020.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2020.png"></p>
<p>再次拉起</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2021.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2021.png"></p>
<p>会持续增加</p>
<h2 id="按照-登录→大厅→录播课→回到大厅"><a href="#按照-登录→大厅→录播课→回到大厅" class="headerlink" title="按照 登录→大厅→录播课→回到大厅"></a>按照 登录→大厅→录播课→回到大厅</h2><h3 id="新版本二进制，移除laya-时候内存"><a href="#新版本二进制，移除laya-时候内存" class="headerlink" title="新版本二进制，移除laya 时候内存"></a>新版本二进制，移除laya 时候内存</h3><p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2022.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2022.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2023.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2023.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2024.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2024.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2025.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2025.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2026.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2026.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2027.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2027.png"></p>
<h2 id="没有做修改的内存"><a href="#没有做修改的内存" class="headerlink" title="没有做修改的内存"></a>没有做修改的内存</h2><p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2028.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2028.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2029.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2029.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2030.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2030.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2031.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2031.png"></p>
<h3 id="对比两种二进制，在laya-是否卸载方面内存变化结论"><a href="#对比两种二进制，在laya-是否卸载方面内存变化结论" class="headerlink" title="对比两种二进制，在laya 是否卸载方面内存变化结论"></a>对比两种二进制，在laya 是否卸载方面内存变化结论</h3><p>很明显能够看到在切换场景的时候内存有一个很深的释放，因为在释放完成第一个layacontroller之后会重新建立一个新的layaController ， 这里会有一个很深的尖角，因为需要载入新的场景和资源，内存会再次上升。因为小游戏在运行时候必须的内存大小基本固定，所以会回归到正常的内存数值。</p>
<p>现有Laya 单利方式在内存表现方面没有太多的增加，在大厅进入到录播AI课的时候会有一定的内存上涨，在从录播AI课回到大厅的时候，一些内存没有释放掉，维持在 396M 左右， 在使用释放laya 的方式，在回到大厅时候，维持大厅刚进入时候的内存值，即 349M 左右。</p>
<p>有一个明显不一样的地方是，如果在新版本中大厅切换到一个空的页面，即无laya 运行时环境，iOS 内存能够从 349M 下降到 85M 左右（如下图）， 但是现有的版本，内存无法下降</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2032.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2032.png"></p>
<p>旧版本如下：</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2033.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2033.png"></p>
<p>具体时机数值比较</p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/f8d0e91dae0746ef856f9b58107a6fe8">Untitled</a></p>
<h2 id="Laya单独一个课件载入到一个新的demo-中"><a href="#Laya单独一个课件载入到一个新的demo-中" class="headerlink" title="Laya单独一个课件载入到一个新的demo 中"></a>Laya单独一个课件载入到一个新的demo 中</h2><p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2034.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2034.png"></p>
<p>在正常运行时候 191M （这里没有声网，没有录播课中的视频，只是laya 课件）， 但是卸载以后，就在 70.3M  </p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2035.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2035.png"></p>
<p>就是理论评估，本讲课件暂用内存在 121M 左右。</p>
<p>在学生端这里，从大厅进入—&gt;到AI录播课→回到大厅流程 （在释放laya 对象时候进行延时处理，延时为 5秒 ，可以详细的记录内存的变化）</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2036.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2036.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2037.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2037.png"></p>
<p>327 - 137 = 190M （相比上面单独demo 中的 121M ，应该算是合理的）</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2038.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2038.png"></p>
<p>大厅课件占用内存  353 - 137  = 216 M</p>
<h2 id="关于性能方面初步结论："><a href="#关于性能方面初步结论：" class="headerlink" title="关于性能方面初步结论："></a>关于性能方面初步结论：</h2><p>在同等环境下，运行时候需要的内存是一致的，但是在于卸载laya 到原生端这里，2.1.0 </p>
<p>版本因为laya 引擎自身原因，引擎运行分配出来的内存和JavaScript context，资源内存并没有被释放。导致再次拉起Laya 工程，内存会重新分配，出现严重的内存泄漏。2.11.0 版本，修改以后是可以释放掉laya运行时内存，不会因为多次释放和重新拉起引起内存泄漏。</p>
<p>渲染侧：</p>
<p>暂时还需要低端机器和相关测试环境对比</p>
<h2 id="内存比对"><a href="#内存比对" class="headerlink" title="内存比对"></a>内存比对</h2><p>比如线上debug 版本，进入ai课执行空游戏，即载入空场景表现</p>
<p>redirect url 之后内存维持在 169M</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2039.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2039.png"></p>
<p>如果使用卸载Laya 方式</p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2040.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2040.png"></p>
<p><img src="/2021/06/04/Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2041.png" alt="Laya%20Native%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0%E7%AC%94%E8%AE%B0%2067e77270abfb45999959e8f3991ec77d/Untitled%2041.png"></p>
<p>相当于如果使用修改后的引擎，在不使用Laya 的环境中 相比之前稳定在 169M 的内存， 能够减少  169 - 82.6 =  86.4M   ,  也就是说可以多出来 86.4M 内存提供给额外业务使用。</p>
<h2 id="后续升级："><a href="#后续升级：" class="headerlink" title="后续升级："></a>后续升级：</h2><p>现有iOS升级可更改的内容非常少，主要修改点在于：</p>
<ol>
<li>iOS 之前单利方式的Laya Controller 更改为对象方式，在需要的时候载入初始化，不需要的时候可以销毁。</li>
<li>替换新版本 laya 原生二进制文件（必要）</li>
<li>JavaScript 部分，修改或者替换apploader.js ,index.js 新增 webglPlus.js</li>
</ol>
<h3 id="新版本特性："><a href="#新版本特性：" class="headerlink" title="新版本特性："></a>新版本特性：</h3><ol>
<li>在新版本Laya 代码中使用的是 WkWebview，iOS 可以使用高版本二进制进行新项目提审。</li>
<li>支持内存释放，可以做多runtime 引擎之间切换。</li>
<li>具备扩展性，可以在现有基础上对引擎底层做特定修改。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/04/07/leetcode%2009/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/07/leetcode%2009/" class="post-title-link" itemprop="url">leetcode 总结  09 反转链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-07 20:03:35" itemprop="dateCreated datePublished" datetime="2021-04-07T20:03:35+08:00">2021-04-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-28 17:19:00" itemprop="dateModified" datetime="2021-05-28T17:19:00+08:00">2021-05-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="leetcode-09-反转链表"><a href="#leetcode-09-反转链表" class="headerlink" title="leetcode 09 反转链表"></a>leetcode 09 反转链表</h1><p>一道比较有意思的题，也觉得是链表里面需要掌握的一道题</p>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：</p>
<p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p>
<p>输入：head = [1,2]<br>输出：[2,1]<br>示例 3：</p>
<p>输入：head = []<br>输出：[]</p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;= Node.val &lt;= 5000</p>
<p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p>作者：力扣 (LeetCode)<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/f58sg/">https://leetcode-cn.com/leetbook/read/linked-list/f58sg/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//因为要返回链表，所以我们先搞一个需要返回的链表指针，初始值先置为空</span></span><br><span class="line">        ListNode * pReturn = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode * p = head; <span class="comment">// 构造另外一个指针，用来标记当前移动指针的位置，也为了持有链表后续的值</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)  <span class="comment">// 链表操作，一般就是while 语句，判空即可，一个节点一个节点的向下遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode * tmp = p-&gt;next; <span class="comment">// 这里需要有一个指针，持有当前操作指针的下一位，因为当前操作指针要被挪出去，后面信息需要保留</span></span><br><span class="line">            p-&gt;next = pReturn; <span class="comment">// 在原始长链中移除的指针，需要插入到返回链表的头结点，所以这里是插入操作。</span></span><br><span class="line">            pReturn = p; <span class="comment">// 原始指针更新当前指向位置，完成了返回链表的插入</span></span><br><span class="line">            p = tmp;  <span class="comment">// 当前工作指针就更新为工作指针的后一位，就是之前保存的原始链表的后续内容</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//最后返回我们已经逆序完成的链表</span></span><br><span class="line">        <span class="keyword">return</span> pReturn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/04/07/leetcode%2008/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/07/leetcode%2008/" class="post-title-link" itemprop="url">leetcode 总结  08 大数相加</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-07 19:14:54" itemprop="dateCreated datePublished" datetime="2021-04-07T19:14:54+08:00">2021-04-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-28 12:18:08" itemprop="dateModified" datetime="2021-05-28T12:18:08+08:00">2021-05-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="leetcode-08-大数相加"><a href="#leetcode-08-大数相加" class="headerlink" title="leetcode 08 大数相加"></a>leetcode 08 大数相加</h1><p>就最近遇到一个比较有特点的题，特点大数这个东西第一次听说这么搞。</p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p>提示：</p>
<p>num1 和num2 的长度都小于 5100<br>num1 和num2 都只包含数字 0-9<br>num1 和num2 都不包含任何前导零<br>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</p>
<p>因为给出的大数是 字符串，考虑到需要逆序，比较容易的方式在自己了解不多的语言中认为 Python 比较好用，因为字符串逆序和字符串分割为数组会比较简单。于是就这么干了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="comment">#翻转 总是要每一位相加的，相加也需要有进位，从最低位到最高位</span></span><br><span class="line">        num_revert_1 = num1[::-<span class="number">1</span>]</span><br><span class="line">        num_revert_2 = num2[::-<span class="number">1</span>]</span><br><span class="line">        len_1 = <span class="built_in">len</span>(num1)</span><br><span class="line">        len_2 = <span class="built_in">len</span>(num2)</span><br><span class="line">        <span class="comment">#取出最大长度数组和最短长度</span></span><br><span class="line">        max_len = len_1 <span class="keyword">if</span> len_1 &gt; len_2 <span class="keyword">else</span> len_2</span><br><span class="line">        mini_len = len_1 <span class="keyword">if</span>  len_1 &lt; len_2 <span class="keyword">else</span> len_2</span><br><span class="line"></span><br><span class="line">        max_str_rever = num_revert_1 <span class="keyword">if</span> max_len == len_1 <span class="keyword">else</span> num_revert_2</span><br><span class="line">        mini_str_rever = num_revert_1 <span class="keyword">if</span> mini_len == len_1 <span class="keyword">else</span> num_revert_2</span><br><span class="line">				<span class="comment"># 如果长度相等，那么无所谓长短</span></span><br><span class="line">        <span class="keyword">if</span> max_len == mini_len:</span><br><span class="line">            max_str_rever = num_revert_1</span><br><span class="line">            mini_str_rever = num_revert_2</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 相加 给一个返回值用于返回，初始值为空</span></span><br><span class="line">        return_str = <span class="string">&quot;&quot;</span></span><br><span class="line">        need_add = <span class="number">0</span> <span class="comment"># 标识位，用来标识当前相加是否需要进位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_len):</span><br><span class="line">          	<span class="comment"># 每次相加的数字暂存 ， 当数组长度不一致时候，在比较小的长度时候是两个数组相加 ， 超过了这个长度就是最大长度的数组自身数值</span></span><br><span class="line">            tmp_add = (<span class="built_in">int</span>(max_str_rever[i]) + <span class="built_in">int</span>(mini_str_rever[i])) <span class="keyword">if</span> (i &lt; mini_len) <span class="keyword">else</span> (<span class="built_in">int</span>(max_str_rever[i]))</span><br><span class="line">            <span class="comment"># 其实tmp_add 基本就差不多能决定下一次是否需要进位了 ， 可是别忘了还有进位 ， 因为进位是个位，所以下面怎么写都行 tmp_add 不可能大于18 ， need_add 不可能大于 1</span></span><br><span class="line">            second_add = tmp_add % <span class="number">10</span>  + need_add <span class="comment"># 加上进位之后的个位数， 也有可能是 10  比如 tmp_add = 9 , need_add = 1</span></span><br><span class="line">            return_str += <span class="built_in">str</span>(second_add % <span class="number">10</span>) <span class="comment"># 所以取余 个位数</span></span><br><span class="line">            need_add = <span class="number">1</span> <span class="keyword">if</span> (second_add &gt;= <span class="number">10</span> <span class="keyword">or</span> tmp_add &gt;= <span class="number">10</span>) <span class="keyword">else</span> <span class="number">0</span>   <span class="comment"># 如果 second_add &gt;= 10 或者 第一次相加都 &gt;= 10 那么就进位</span></span><br><span class="line">        <span class="comment">#如果到最后发现进位标识符还是 1， 那么最高位再补一个 1</span></span><br><span class="line">        <span class="keyword">if</span> need_add == <span class="number">1</span>:</span><br><span class="line">            return_str += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">				<span class="comment">#最后内容翻转就是我们需要输出的</span></span><br><span class="line">        <span class="keyword">return</span> return_str[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/03/03/leetcode%2001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/03/leetcode%2001/" class="post-title-link" itemprop="url">leetcode 总结  01 两数之和</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-03 20:14:34 / 修改时间：21:09:02" itemprop="dateCreated datePublished" datetime="2021-03-03T20:14:34+08:00">2021-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="leetcode-总结-01-两数之和"><a href="#leetcode-总结-01-两数之和" class="headerlink" title="leetcode 总结  01 两数之和"></a>leetcode 总结  01 两数之和</h1><p>经历了非常严重的一整年加班以后，开始想着不要继续碌碌无为了。算法这些东西，不管是需要找工作临时练手熟悉，或者是学习，总是要有的。</p>
<p>废话不多说。</p>
<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
<p>提示：</p>
<p>2 &lt;= nums.length &lt;= 103<br>-109 &lt;= nums[i] &lt;= 109<br>-109 &lt;= target &lt;= 109<br>只会存在一个有效答案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 两数之和 ， 一个数组 ， 一个 之和 ， 那么 总和减去当前数值 ， 就是需要查找的一个数字 。查看这个数字是否在于这个数组中</span></span><br><span class="line">      	<span class="comment">// 思路：用一个表用于查询第二个数值是否存在， 并且能取出第二个数值在提供数组中的位置 ，那么方便点儿就是 map了 。 key 作为数值 ，value 是索引</span></span><br><span class="line">        <span class="comment">// 构建一个哈希表，用于存放数据和查询 unordered_map  不需要排序</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="comment">// 一次遍历，从头开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  遍历器查询缺值是否存在当前哈希表中</span></span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.find(target - nums[i]);</span><br><span class="line">            <span class="comment">// 如果存在</span></span><br><span class="line">            <span class="keyword">if</span>(it != hashtable.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 返回，哈希表中存放的匹配值的位置，和当前位置</span></span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;  <span class="comment">// 注意返回值类型</span></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果不存在，那么放入当前的值和index</span></span><br><span class="line">                hashtable[nums[i]] = i;  <span class="comment">// 第一位是数字 ，第二位是在数组中的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 查不到肯定返回为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://waitingchange.github.io/2021/03/03/leetcode%2002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="change">
      <meta itemprop="description" content="仓库坏了，丢了一些内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人的胡言乱语">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/03/leetcode%2002/" class="post-title-link" itemprop="url">leetcode 总结 02 只出现一次的数字</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-03 20:14:34 / 修改时间：21:08:52" itemprop="dateCreated datePublished" datetime="2021-03-03T20:14:34+08:00">2021-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="leetcode-总结-02-只出现一次的数字"><a href="#leetcode-总结-02-只出现一次的数字" class="headerlink" title="leetcode 总结 02 只出现一次的数字"></a>leetcode 总结 02 只出现一次的数字</h1><h4 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<p>作者：力扣 (LeetCode)<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/top-interview-questions/xm0u83/">https://leetcode-cn.com/leetbook/read/top-interview-questions/xm0u83/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最开始考虑是不是先要排序，然后相邻的进行比较 ， 但是不需要额外空间这个要求就一定会有诡异，所以查了一下解题技巧，果然很有一套</span></span><br><span class="line"><span class="comment">// 技巧就是  0  异或 任何数字 都是另外的数字</span></span><br><span class="line"><span class="comment">// 相同的数字异或本身 刚好为 0 </span></span><br><span class="line"><span class="comment">// 那么 数组中的每一位都进行异或运算，得出的就是出现单次的数字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> singleNum = <span class="number">0</span>; <span class="comment">// 定义需要return 的数字， 先赋值为 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; nums.size();i++ ) <span class="comment">// 根据长度进行一次遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            singleNum = singleNum ^ nums[i]; <span class="comment">// 执行异或逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleNum; <span class="comment">// 返回需要的单一数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">change</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
